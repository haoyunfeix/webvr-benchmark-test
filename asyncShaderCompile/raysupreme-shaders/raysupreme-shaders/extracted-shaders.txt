[76236:775:0606/210332.560440:ERROR:configuration_policy_handler_list.cc(91)] Unknown policy: NTPContentSuggestionsEnabled
2018-06-06 21:03:33.008 Chromium[76236:7076033] *** Owner supplied to -[NSTrackingArea initWithRect:options:owner:userInfo:] referenced a deallocating object. Tracking area behavior is undefined. Break on NSTrackingAreaDeallocatingOwnerError to debug.
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
attribute vec4 vPos;
attribute vec2 vTexCoord;
varying vec2 texCoord;
void main(){
   texCoord = vec2(vTexCoord.x, 1.0-vTexCoord.y);
   gl_Position = vPos;
}

__FRAGMENTSHADER__
#version 100
precision mediump float;
uniform sampler2D tex;
uniform float alpha;
uniform bool premAlpha;
varying vec2 texCoord;
void main(){
   vec4 color = texture2D(tex, texCoord);
   if(premAlpha){
       gl_FragColor = vec4(clamp( color.r * alpha, 0.0, 1.0), clamp( color.g * alpha, 0.0, 1.0), clamp( color.b * alpha, 0.0, 1.0), clamp( color.a * alpha, 0.0, 1.0) );
   }else{
       gl_FragColor = vec4(color.rgb, clamp( color.a * alpha, 0.0, 1.0) );
   }
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

attribute vec4 drawPosition;
attribute vec4 drawColor;
uniform mat4 pM;
varying vec4 v_Color;

void main() {
  gl_Position =  pM * drawPosition;
  v_Color = drawColor;
}

__FRAGMENTSHADER__
#version 100

precision mediump float;
varying vec4 v_Color;
uniform float uniformAlpha;
void main() {
  vec4 color = v_Color;
  gl_FragColor = vec4( color.rgb, color.a * uniformAlpha );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
attribute vec2 vPos;
uniform mat4 tM;
uniform mat4 pM;
void main() {
  mat4 m = pM * tM;
  gl_Position = m * vec4(vPos, 0, 1);
}
__FRAGMENTSHADER__
#version 100
precision mediump float;
uniform vec4 color;
uniform float uniformAlpha;
void main() {
  gl_FragColor = color;
  gl_FragColor = vec4( color.rgb, color.a * uniformAlpha );
}
__ENDPROGRAM__
[76236:34563:0606/210338.140895:ERROR:external_policy_data_updater.cc(263)] The fetched data doesn't match the expected hash.
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

attribute vec2 vPos;
attribute vec2 vTexCoord;

varying vec2 texCoord;

void main() {
   texCoord = vTexCoord;
   texCoord.y = 1.0 - vTexCoord.y;
   gl_Position = vec4(vPos, 0, 1);}
__FRAGMENTSHADER__
#version 100

precision mediump float;

uniform sampler2D tex;

uniform float alpha;

uniform bool remPremAlpha;

uniform bool multAlphaOnly;

varying vec2 texCoord;

void main() {
  vec4 color = texture2D(tex, texCoord);
  if ( remPremAlpha ) gl_FragColor = vec4(color.a > 0. ? color.rgb / color.a : vec3(0), color.a); else 
  if ( multAlphaOnly ) gl_FragColor = vec4( color.rgb, color.a * alpha ); else gl_FragColor = vec4( color.r * alpha, color.g * alpha, color.b * alpha, color.a * alpha );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100

attribute vec4 drawPosition;
attribute vec4 drawColor;
uniform mat4 pM;
varying vec4 v_Color;

void main() {
  gl_Position =  pM * drawPosition;
  v_Color = drawColor;
}

__FRAGMENTSHADER__
#version 100

precision mediump float;
varying vec4 v_Color;
uniform float uniformAlpha;
void main() {
  vec4 color = v_Color;
  gl_FragColor = vec4( color.rgb, color.a * uniformAlpha );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
attribute vec2 vPos;
uniform mat4 tM;
uniform mat4 pM;
void main() {
  mat4 m = pM * tM;
  gl_Position = m * vec4(vPos, 0, 1);
}
__FRAGMENTSHADER__
#version 100
precision mediump float;
uniform vec4 color;
uniform float uniformAlpha;
void main() {
  gl_FragColor = color;
  gl_FragColor = vec4( color.rgb, color.a * uniformAlpha );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
                precision highp float;
                in vec4 aPosition;
                in vec2 aTexCoord;
                out vec2 texCoord;

                void main() {
                    texCoord = vec2(aTexCoord.x, 1.0- aTexCoord.y);
                    gl_Position = aPosition;
                }
__FRAGMENTSHADER__
#version 300 es
                precision mediump float;

                out vec4 fragColor;
                in vec2 texCoord;

                uniform vec2 inResolution;
            // dimensions of the color picker (in range (0,1])
#define CP_WIDTH  0.8
#define CP_HEIGHT 1.0

// position of the color picker (in range [0,1])
// relative to the bottom left corner
#define CP_POS_X 0.2
#define CP_POS_Y 0.0

// relative widths of the color picker widgets (in range (0,1])
#define SV_WIDGET_WIDTH 0.94
#define H_WIDGET_WIDTH  0.05

// dimensions of the circular sat/val marker
#define SAT_VAL_MARKER_OUTER_RADIUS 0.03 * 0.4
#define SAT_VAL_MARKER_INNER_RADIUS 0.025 * 0.4

// thickness of the hue marker
#define VAL_MARKER_THICKNESS 0.005


const int num_color_stops = 6;

uniform vec3 uCoords, uCoords2;
uniform int uCurrent;

// interpolation helpers

vec3 get_color_stop(int i) {
    vec3 result = vec3(0);

    if (i == 0) 	 result = vec3(1.0, 0.0, 0.0);
    else if (i == 1) result = vec3(1.0, 0.0, 1.0);
    else if (i == 2) result = vec3(0.0, 0.0, 1.0);
    else if (i == 3) result = vec3(0.0, 1.0, 1.0);
    else if (i == 4) result = vec3(0.0, 1.0, 0.0);
    else if (i == 5) result = vec3(1.0, 1.0, 0.0);

    return result;

}

vec2 get_sat_val_from_position(in vec2 pos) {

    vec2 result = vec2(0.0);

   	vec2 tl = vec2(0.0, 0.0);
    vec2 bl = vec2(0.0, 0.0);
    vec2 br = vec2(0.0, 1.0);
    vec2 tr = vec2(1.0, 0.0);

    vec2 interp_b = mix(bl, br, pos.x);
    vec2 interp_t = mix(tl, tr, pos.x);

    result = mix(interp_b, interp_t, pos.y);

    return result;
}

vec3 get_hue_from_position(in float pos) {

    vec3 result = vec3(0.0);

    const float frac = 1.0 / float(num_color_stops);

    for (int i = 0; i < num_color_stops; ++i) {

    	if (pos <= frac * float(i + 1)) {

        	int n = i + 1;
        	if (n == num_color_stops) {
            	n = 0;
        	};

        	result = mix(get_color_stop(i), get_color_stop(n), (pos - frac * float(i)) * 1.0 / frac);
        	break;
      	}
    }

    return result;
}

vec3 apply_sat_val_to_color(in vec2 sat_val, in vec3 color) {
	vec3 val = mix(vec3(0.0), vec3(1.0), sat_val.y);
    return mix(val, color, sat_val.x);
}



// drawing functions

vec3 draw_sat_val(in vec2 uv, in vec3 selected_hue, in vec3 selection_position) {

  	vec3 final = vec3(0.0);

	vec2 rel_uv = vec2((uv.x - CP_POS_X) / CP_WIDTH, (uv.y - CP_POS_Y) / CP_HEIGHT);

  	if (rel_uv.x >= 0.0 && rel_uv.x <= 1.0 &&
        rel_uv.y >= 0.0 && rel_uv.y <= 1.0 &&
        rel_uv.x <= SV_WIDGET_WIDTH) {

    	vec2 sat_val = get_sat_val_from_position(vec2(rel_uv.x / SV_WIDGET_WIDTH, rel_uv.y));

    	final = apply_sat_val_to_color(sat_val, selected_hue);

    	// draw selection marker
        float aspect_ratio = inResolution.y / inResolution.x;
        //aspect_ratio = 1.0;

    	float dist = length(
            vec2(rel_uv.x, rel_uv.y * aspect_ratio) -
            vec2(selection_position.x, selection_position.y * aspect_ratio)
        );

    	if (dist <= SAT_VAL_MARKER_OUTER_RADIUS &&
        	dist >= SAT_VAL_MARKER_INNER_RADIUS) {

      		float smoothing = (dist - SAT_VAL_MARKER_INNER_RADIUS) /
        		              (SAT_VAL_MARKER_OUTER_RADIUS - SAT_VAL_MARKER_INNER_RADIUS);

      		smoothing = 1.0 - abs((smoothing * 2.0 - 1.0) * 0.5);

      		final = mix(final, vec3(1.0) - final, smoothing);
    	}
  	}

  	return final;

}

vec3 draw_hue(in vec2 uv, in vec3 selection_position) {

  	vec3 final = vec3(0.0);

    vec2 rel_uv = vec2((uv.x - CP_POS_X) / CP_WIDTH, (uv.y - CP_POS_Y) / CP_HEIGHT);

  	if (rel_uv.x >= 0.0 && rel_uv.x <= 1.0 &&
        rel_uv.y >= 0.0 && rel_uv.y <= 1.0 &&
        1.0 - rel_uv.x <= H_WIDGET_WIDTH) {

		final = get_hue_from_position(rel_uv.y);

    	// draw selection marker
    	float dist = abs(rel_uv.y - selection_position.z);

    	if (dist <= VAL_MARKER_THICKNESS) {
      		final = vec3(1.0) - final;
    	}
  	}

  	return final;

}

void main()
{
	vec2 uv = texCoord;//fragCoord.xy / iResolution.xy;

    vec3 final_color = vec3(0.0);

    // draw color picker

    // selected_position.xy : relative xy coords of selection in sat/val widget
    // selected_position.z  : relative y coord of selection in hue widget
    vec3 selection_position;
    vec3 off_position;

    if ( uCurrent == 0 ) {
        selection_position = uCoords;
        off_position = uCoords2;
    } else {
        selection_position = uCoords2;
        off_position = uCoords;
    }

    // --- Selected Color

    vec3 selected_hue = get_hue_from_position(selection_position.z);

    vec2 sat_val = get_sat_val_from_position(
        vec2(selection_position.x / SV_WIDGET_WIDTH, selection_position.y)
    );

    vec3 selected_color = apply_sat_val_to_color(sat_val, selected_hue);

    // --- Off Color

    vec3 off_hue = get_hue_from_position(off_position.z);

    sat_val = get_sat_val_from_position(
        vec2(off_position.x / SV_WIDGET_WIDTH, off_position.y)
    );

    vec3 off_color = apply_sat_val_to_color(sat_val, off_hue);

    // ---

    final_color += draw_sat_val(uv, selected_hue, selection_position);
    final_color += draw_hue(uv, selection_position);

    // draw colorized windows
    vec3 tl = vec3(0);//texture(iChannel1, (uv - vec2(0.0, 0.5)) * 2.0).rgb;
    vec3 tr = vec3(0);//texture(iChannel2, (uv - vec2(0.5, 0.5)) * 2.0).rgb;
    vec3 br = vec3(0);//texture(iChannel3, (uv - vec2(0.5, 0.0)) * 2.0).rgb;

    // replace green by selected color
    float dist_to_green = length(vec3(0.0, 1.0, 0.0) - tl);
    tl = mix(selected_color, tl, dist_to_green);

    dist_to_green = length(vec3(0.0, 1.0, 0.0) - tr);
    tr = mix(selected_color, tr, dist_to_green);

    // colorize with selected color
    br *= selected_color;

    // if (uv.x <= 0.5 && uv.y >= 0.5) final_color = tl;
    // else if (uv.x > 0.5 && uv.y >= 0.5) final_color = tr;
    // else if (uv.x > 0.5 && uv.y < 0.5) final_color = br;

    if (uv.x <= CP_POS_X ) {
        if ( uCurrent == 0 ) {
            if ( uv.y >= 0.5 ) final_color = selected_color;
            else
            if ( uv.y <= 0.5 ) final_color = off_color;

            if ( uv.x >= CP_POS_X - 0.0025 && uv.y >= 0.5 ) final_color = vec3( 0.5 );
        } else {
            if ( uv.y >= 0.5 ) final_color = off_color;
            else
            if ( uv.y <= 0.5 ) final_color = selected_color;

            if ( uv.x >= CP_POS_X - 0.0025 && uv.y <= 0.5 ) final_color = vec3( 0.5 );
        }

        if ( uv.y >= 0.49005 && uv.y < 0.5005 ) final_color = vec3( 0.5 );
    }


    fragColor = vec4(final_color, 1.0);
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    res=opU( res, vec3( sdCapsule( p, vec3( -0.800, 0.000, 0.000 ), vec3( 0.800, 0.000, 0.000 ), 0.200), 0, 0 ) );
    return res;
}
#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];

vec3 calcNormal( in vec3 pos )
{

    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );

    // float eps = 0.01; // precission",
    // float gradX = map( pos + vec3(eps, 0.0, 0.0) ).x - map( pos - vec3(eps, 0.0, 0.0) ).x;
    // float gradY = map( pos + vec3(0.0, eps, 0.0) ).x - map( pos - vec3(0.0, eps, 0.0) ).x;
    // float gradZ = map( pos + vec3(0.0, 0.0, eps) ).x - map( pos - vec3(0.0, 0.0, eps) ).x;
    // return normalize( vec3( gradX, gradY, gradZ ) );
}

/*
vec3 calcNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}*/

// --- Cast a ray into the scene

vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<uSteps; i++ )
    {
        float precis = 0.0005 * t;

        vec3 res = map( ro+rd*t );
        
        if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}


// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}
vec3 hitScene( in vec3 ro, in vec3 rd, out MaterialInfo material, out vec3 normal )
{
    float tmin=uTMin, tmax=uTMax;

    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        normal = calcNormal( ro + rd * hit.x );

        material = uMaterials[matIndex];
    }

    return hit;
}

vec3 hitScene2( in vec3 ro, in vec3 rd, out MaterialInfo material )
{
    float tmin=uTMin, tmax=uTMax;
    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 ) {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    return hit;
}
vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
vec4 color=vec4(0,0,0,0);
vec4 topColor = vec4( 0.1229, 0.3628, 0.7820, 1.0000 );
vec4 bottomColor = vec4( 1.0000, 1.0000, 1.0000, 1.0000 );
float t = 0.5 * ( rd.y + 1.0 );
vec4 backColor = ( vec4( 1.0 )  - vec4( t )  ) * bottomColor + vec4( t )  * topColor;
color = vec4( backColor.x, backColor.y, backColor.z, 1.0 ) ;

return color;
}// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.5, 0.5));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));

vec4 getColor( in Ray ray )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    vec3 hit = hitScene2( ray.origin, ray.dir, material );

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        if ( hit.z == uSelectedId )
        {
            color = vec4( 0.416, 0.416, 0.78, 1.0 );
        } else
        {
            color = vec4( clamp( pow( material.baseColor, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
        }
    }

    else { color = background( ray.origin, ray.dir, normalize( uSunDir ) ); color = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a ); }

    return color;
}

out vec4 outColor;

void main()
{
    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    // --- Camera

    const float fov = 80.0;
    float halfWidth = tan(radians(fov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand = vec2(0.5);

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    outColor = getColor( Ray( uOrigin, normalize(dir) ) );
    // outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    res=opU( res, vec3( sdConeSection( p, 1.000, 1.000, 0.000), 0, 0 ) );
    return res;
}
#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];

vec3 calcNormal( in vec3 pos )
{

    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );

    // float eps = 0.01; // precission",
    // float gradX = map( pos + vec3(eps, 0.0, 0.0) ).x - map( pos - vec3(eps, 0.0, 0.0) ).x;
    // float gradY = map( pos + vec3(0.0, eps, 0.0) ).x - map( pos - vec3(0.0, eps, 0.0) ).x;
    // float gradZ = map( pos + vec3(0.0, 0.0, eps) ).x - map( pos - vec3(0.0, 0.0, eps) ).x;
    // return normalize( vec3( gradX, gradY, gradZ ) );
}

/*
vec3 calcNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}*/

// --- Cast a ray into the scene

vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<uSteps; i++ )
    {
        float precis = 0.0005 * t;

        vec3 res = map( ro+rd*t );
        
        if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}


// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}
vec3 hitScene( in vec3 ro, in vec3 rd, out MaterialInfo material, out vec3 normal )
{
    float tmin=uTMin, tmax=uTMax;

    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        normal = calcNormal( ro + rd * hit.x );

        material = uMaterials[matIndex];
    }

    return hit;
}

vec3 hitScene2( in vec3 ro, in vec3 rd, out MaterialInfo material )
{
    float tmin=uTMin, tmax=uTMax;
    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 ) {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    return hit;
}
vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
vec4 color=vec4(0,0,0,0);
vec4 topColor = vec4( 0.1229, 0.3628, 0.7820, 1.0000 );
vec4 bottomColor = vec4( 1.0000, 1.0000, 1.0000, 1.0000 );
float t = 0.5 * ( rd.y + 1.0 );
vec4 backColor = ( vec4( 1.0 )  - vec4( t )  ) * bottomColor + vec4( t )  * topColor;
color = vec4( backColor.x, backColor.y, backColor.z, 1.0 ) ;

return color;
}// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.5, 0.5));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));

vec4 getColor( in Ray ray )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    vec3 hit = hitScene2( ray.origin, ray.dir, material );

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        if ( hit.z == uSelectedId )
        {
            color = vec4( 0.416, 0.416, 0.78, 1.0 );
        } else
        {
            color = vec4( clamp( pow( material.baseColor, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
        }
    }

    else { color = background( ray.origin, ray.dir, normalize( uSunDir ) ); color = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a ); }

    return color;
}

out vec4 outColor;

void main()
{
    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    // --- Camera

    const float fov = 80.0;
    float halfWidth = tan(radians(fov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand = vec2(0.5);

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    outColor = getColor( Ray( uOrigin, normalize(dir) ) );
    // outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    res=opU( res, vec3( length( max( abs( p) - vec3( 0.990, 0.990, 0.990 ), 0.0 ) ) - 0.010, 0, 0 ) );
    return res;
}
#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];

vec3 calcNormal( in vec3 pos )
{

    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );

    // float eps = 0.01; // precission",
    // float gradX = map( pos + vec3(eps, 0.0, 0.0) ).x - map( pos - vec3(eps, 0.0, 0.0) ).x;
    // float gradY = map( pos + vec3(0.0, eps, 0.0) ).x - map( pos - vec3(0.0, eps, 0.0) ).x;
    // float gradZ = map( pos + vec3(0.0, 0.0, eps) ).x - map( pos - vec3(0.0, 0.0, eps) ).x;
    // return normalize( vec3( gradX, gradY, gradZ ) );
}

/*
vec3 calcNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}*/

// --- Cast a ray into the scene

vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<uSteps; i++ )
    {
        float precis = 0.0005 * t;

        vec3 res = map( ro+rd*t );
        
        if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}


// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}
vec3 hitScene( in vec3 ro, in vec3 rd, out MaterialInfo material, out vec3 normal )
{
    float tmin=uTMin, tmax=uTMax;

    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        normal = calcNormal( ro + rd * hit.x );

        material = uMaterials[matIndex];
    }

    return hit;
}

vec3 hitScene2( in vec3 ro, in vec3 rd, out MaterialInfo material )
{
    float tmin=uTMin, tmax=uTMax;
    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 ) {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    return hit;
}
vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
vec4 color=vec4(0,0,0,0);
vec4 topColor = vec4( 0.1229, 0.3628, 0.7820, 1.0000 );
vec4 bottomColor = vec4( 1.0000, 1.0000, 1.0000, 1.0000 );
float t = 0.5 * ( rd.y + 1.0 );
vec4 backColor = ( vec4( 1.0 )  - vec4( t )  ) * bottomColor + vec4( t )  * topColor;
color = vec4( backColor.x, backColor.y, backColor.z, 1.0 ) ;

return color;
}// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.5, 0.5));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));

vec4 getColor( in Ray ray )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    vec3 hit = hitScene2( ray.origin, ray.dir, material );

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        if ( hit.z == uSelectedId )
        {
            color = vec4( 0.416, 0.416, 0.78, 1.0 );
        } else
        {
            color = vec4( clamp( pow( material.baseColor, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
        }
    }

    else { color = background( ray.origin, ray.dir, normalize( uSunDir ) ); color = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a ); }

    return color;
}

out vec4 outColor;

void main()
{
    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    // --- Camera

    const float fov = 80.0;
    float halfWidth = tan(radians(fov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand = vec2(0.5);

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    outColor = getColor( Ray( uOrigin, normalize(dir) ) );
    // outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

float sdCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    res=opU( res, vec3( sdCylinder( p, vec2( 1.000, 1.000) ), 0, 0 ) );
    return res;
}
#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];

vec3 calcNormal( in vec3 pos )
{

    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );

    // float eps = 0.01; // precission",
    // float gradX = map( pos + vec3(eps, 0.0, 0.0) ).x - map( pos - vec3(eps, 0.0, 0.0) ).x;
    // float gradY = map( pos + vec3(0.0, eps, 0.0) ).x - map( pos - vec3(0.0, eps, 0.0) ).x;
    // float gradZ = map( pos + vec3(0.0, 0.0, eps) ).x - map( pos - vec3(0.0, 0.0, eps) ).x;
    // return normalize( vec3( gradX, gradY, gradZ ) );
}

/*
vec3 calcNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}*/

// --- Cast a ray into the scene

vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<uSteps; i++ )
    {
        float precis = 0.0005 * t;

        vec3 res = map( ro+rd*t );
        
        if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}


// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}
vec3 hitScene( in vec3 ro, in vec3 rd, out MaterialInfo material, out vec3 normal )
{
    float tmin=uTMin, tmax=uTMax;

    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        normal = calcNormal( ro + rd * hit.x );

        material = uMaterials[matIndex];
    }

    return hit;
}

vec3 hitScene2( in vec3 ro, in vec3 rd, out MaterialInfo material )
{
    float tmin=uTMin, tmax=uTMax;
    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 ) {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    return hit;
}
vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
vec4 color=vec4(0,0,0,0);
vec4 topColor = vec4( 0.1229, 0.3628, 0.7820, 1.0000 );
vec4 bottomColor = vec4( 1.0000, 1.0000, 1.0000, 1.0000 );
float t = 0.5 * ( rd.y + 1.0 );
vec4 backColor = ( vec4( 1.0 )  - vec4( t )  ) * bottomColor + vec4( t )  * topColor;
color = vec4( backColor.x, backColor.y, backColor.z, 1.0 ) ;

return color;
}// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.5, 0.5));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));

vec4 getColor( in Ray ray )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    vec3 hit = hitScene2( ray.origin, ray.dir, material );

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        if ( hit.z == uSelectedId )
        {
            color = vec4( 0.416, 0.416, 0.78, 1.0 );
        } else
        {
            color = vec4( clamp( pow( material.baseColor, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
        }
    }

    else { color = background( ray.origin, ray.dir, normalize( uSunDir ) ); color = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a ); }

    return color;
}

out vec4 outColor;

void main()
{
    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    // --- Camera

    const float fov = 80.0;
    float halfWidth = tan(radians(fov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand = vec2(0.5);

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    outColor = getColor( Ray( uOrigin, normalize(dir) ) );
    // outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

float cylinder6length6( vec2 p )
{
	p = p*p*p; p = p*p;
	return pow( p.x + p.y, 1.0/6.0 );
}

float sdCylinder6( vec3 p, vec2 h )
{
    return max( cylinder6length6(p.xz)-h.x, abs(p.y)-h.y );
}
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    res=opU( res, vec3( sdCylinder6( p, vec2( 1.000, 1.000) ), 0, 0 ) );
    return res;
}
#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];

vec3 calcNormal( in vec3 pos )
{

    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );

    // float eps = 0.01; // precission",
    // float gradX = map( pos + vec3(eps, 0.0, 0.0) ).x - map( pos - vec3(eps, 0.0, 0.0) ).x;
    // float gradY = map( pos + vec3(0.0, eps, 0.0) ).x - map( pos - vec3(0.0, eps, 0.0) ).x;
    // float gradZ = map( pos + vec3(0.0, 0.0, eps) ).x - map( pos - vec3(0.0, 0.0, eps) ).x;
    // return normalize( vec3( gradX, gradY, gradZ ) );
}

/*
vec3 calcNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}*/

// --- Cast a ray into the scene

vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<uSteps; i++ )
    {
        float precis = 0.0005 * t;

        vec3 res = map( ro+rd*t );
        
        if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}


// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}
vec3 hitScene( in vec3 ro, in vec3 rd, out MaterialInfo material, out vec3 normal )
{
    float tmin=uTMin, tmax=uTMax;

    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        normal = calcNormal( ro + rd * hit.x );

        material = uMaterials[matIndex];
    }

    return hit;
}

vec3 hitScene2( in vec3 ro, in vec3 rd, out MaterialInfo material )
{
    float tmin=uTMin, tmax=uTMax;
    vec3 hit = castRay( ro, rd, tmin, tmax );

    if ( hit.y >= 0.0 && hit.z < 10000.0 ) {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    return hit;
}
vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
vec4 color=vec4(0,0,0,0);
vec4 topColor = vec4( 0.1229, 0.3628, 0.7820, 1.0000 );
vec4 bottomColor = vec4( 1.0000, 1.0000, 1.0000, 1.0000 );
float t = 0.5 * ( rd.y + 1.0 );
vec4 backColor = ( vec4( 1.0 )  - vec4( t )  ) * bottomColor + vec4( t )  * topColor;
color = vec4( backColor.x, backColor.y, backColor.z, 1.0 ) ;

return color;
}// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.5, 0.5));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));

vec4 getColor( in Ray ray )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    vec3 hit = hitScene2( ray.origin, ray.dir, material );

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        if ( hit.z == uSelectedId )
        {
            color = vec4( 0.416, 0.416, 0.78, 1.0 );
        } else
        {
            color = vec4( clamp( pow( material.baseColor, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
        }
    }

    else { color = background( ray.origin, ray.dir, normalize( uSunDir ) ); color = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a ); }

    return color;
}

out vec4 outColor;

void main()
{
    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    // --- Camera

    const float fov = 80.0;
    float halfWidth = tan(radians(fov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand = vec2(0.5);

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    outColor = getColor( Ray( uOrigin, normalize(dir) ) );
    // outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), color.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

layout(location=0) out vec4 ro;
layout(location=1) out vec4 rd;
// layout(location=2) out vec4 tcol;
// layout(location=3) out vec4 fcol;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform float uTime;
uniform bool uJitter;

vec2 randv2;

vec2 rand2() {// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html
    randv2 += vec2(1.0,1.0);
    return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453), fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));
}

void main()
{
    // --- Setup Camera

    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    randv2 = fract(cos((vTexCoord.xy+vTexCoord.yx*vec2(1000.0,1000.0))+vec2(uTime)*10.0));

    float halfWidth = tan(radians(uFov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand;

    if ( uJitter ) rand = rand2();
    else rand = vec2( 0.5 );

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    // ---

    ro = vec4( uOrigin, 0 );
    rd = vec4( normalize( dir ), 0 );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision mediump float;

in vec2 vTexCoord;

uniform vec3 uSunDir;
uniform bool uSunActive;

uniform float uStepSize, uTMin, uTMax;
uniform int uSteps;


struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3  emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};



#define MAX_MATERIALS 1
uniform MaterialInfo uMaterials[MAX_MATERIALS];




// --- Structs

struct Ray {
    vec3 origin;
    vec3 dir;
};

uniform float uSelectedId;

// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.3, 0.7));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));
const vec3 L2 = normalize(vec3(0, 0.5, 0));

// ---

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;

vec4 getColor( in Ray ray, in vec3 hit )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;
    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;

        

        if ( hit.z == uSelectedId )
        {
            material.baseColor = vec3( 0.5, 0.5, 1.0 );
            color = vec4( material.baseColor * vec3(0.5, 0.5, 1.0) * clamp(dot(L, normal), 0.3, 1.0), 1.0 );
        } else
        {
            color = vec4( material.baseColor * clamp(max(max(dot(L, normal),dot(L1, normal)), dot(L2, normal)), 0.3, 1.0), 1.0 );
        }
    }

    

    return color;
}

out vec4 outColor;

void main()
{
    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );

    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;

    outColor = getColor( Ray( inRO.xyz, inRD.xyz ), hit );
    outColor = vec4( clamp( pow( outColor.xyz, vec3(0.4545) ), 0.0, 1.0 ), outColor.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}


uniform mat4 uInvertLocalTransform;
uniform vec3 uLocalScale;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;



vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    return res;
}


uniform sampler2D uRO, uRD, uHit, uNormal;

uniform int uOffset, uStep;
uniform float uTMin, uTMax;
uniform float uStepSize;

layout(location=0) out vec4 outHit;
layout(location=1) out vec4 outNormal;

vec3 calcNormalA(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x
    );
    return normalize(nor);
}

const int NORMAL_STEPS = 6;

vec3 calcNormalB(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).x * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

/*
vec3 calc_normal(vec3 p) {

    vec3 epsilon = vec3(0.001, 0., 0.);

    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,
                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,
                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);

    return normalize(n);
}*/

vec3 castRay( in vec3 ro, in vec3 rd, in float tmax, in vec3 res )
{
    float t=res.x, m=res.y, id=res.z;

    for( int i = uOffset; i < (uOffset + uStep); i++ )
    {
        float precis = 0.0001;// * t;

        vec3 res = map( ro+rd*t );
        // <! ABS !>
        // if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        if ( res.x <= precis ) {
            m = res.y;
            id = res.z;
            break;
        }
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}

void main()
{
    vec3 inRO = textureLod( uRO, vTexCoord, 0.0 ).xyz;
    vec3 inRD = textureLod( uRD, vTexCoord, 0.0 ).xyz;

    vec3 res, normal = vec3( 0 );

    if ( uOffset == 0 ) res = vec3( uTMin, -1, -1 );
    else {
        res = textureLod( uHit, vTexCoord, 0.0 ).xyz;
        normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

        if ( res.y >= 0.0 ) {
            outHit = vec4( res, 1.0 );
            outNormal = vec4( normal, 1.0 );
            return;
        }
    }

    vec3 hit = castRay( inRO, inRD, uTMax, res );
    if ( hit.y >= 0.0 ) {
        normal = calcNormalB( inRO + inRD * hit.x );
    }

    outHit = vec4( hit, 1.0 );
    outNormal = vec4( normal, 1.0 );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision mediump float;

in vec2 vTexCoord;

uniform vec3 uSunDir;
uniform bool uSunActive;

uniform float uStepSize, uTMin, uTMax;
uniform int uSteps;


struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3  emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};



#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];




// --- Structs

struct Ray {
    vec3 origin;
    vec3 dir;
};

uniform float uSelectedId;

// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.3, 0.7));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));
const vec3 L2 = normalize(vec3(0, 0.5, 0));

// ---

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;

vec4 getColor( in Ray ray, in vec3 hit )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;
    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;

        

        if ( hit.z == uSelectedId )
        {
            material.baseColor = vec3( 0.5, 0.5, 1.0 );
            color = vec4( material.baseColor * vec3(0.5, 0.5, 1.0) * clamp(dot(L, normal), 0.3, 1.0), 1.0 );
        } else
        {
            color = vec4( material.baseColor * clamp(max(max(dot(L, normal),dot(L1, normal)), dot(L2, normal)), 0.3, 1.0), 1.0 );
        }
    }

    

    return color;
}

out vec4 outColor;

void main()
{
    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );

    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;

    outColor = getColor( Ray( inRO.xyz, inRD.xyz ), hit );
    outColor = vec4( clamp( pow( outColor.xyz, vec3(0.4545) ), 0.0, 1.0 ), outColor.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}


uniform mat4 uInvertLocalTransform;
uniform vec3 uLocalScale;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;



vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    vec3 gResult1;
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp.y = tp.y + -0.7000;
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.900, 0.693, 9.900 ), 0.0 ) ) - 0.010, 0, 0 ) );
   tp=p;
    tp.xz = tp.xz + vec2(-5.8329,-9.1131);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 3.480, 0.990, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-2.9951,-0.3052,-9.3829);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 2 ) );
   tp=p;
    tp = tp + vec3(5.4084,-0.6615,-13.9547);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 7.233, 1.864, 7.908 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(1.8432,-0.9806,-7.3413);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 3.960, 0.198, 1.729 ), 0.0 ) ) - 0.010, 0, 5 ) );
   tp=p;
    tp = tp + vec3(2.2985,-0.5698,-7.7168);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.257, 0.198, 1.729 ), 0.0 ) ) - 0.010, 0, 6 ) );
   tp=p;
    tp = tp + vec3(2.6548,-0.1705,-7.1889);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.653, 0.198, 2.657 ), 0.0 ) ) - 0.010, 0, 7 ) );
   tp=p;
    tp = tp + vec3(-7.0562,-0.6615,-2.0499);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.933, 0.797, 7.908 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(10.2510,-0.6615,-2.0499);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.933, 0.797, 7.908 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(6.9955,-3.3000,-3.7075);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.939, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 11 ) );
   tp=p;
    tp = tp + vec3(7.1909,-3.2000,-3.7807);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 1.188, 1.584, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-3.8335,-3.3000,-3.7075);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 5.138, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 13 ) );
   tp=p;
    tp = tp + vec3(-5.9189,-3.2000,-3.7807);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.376, 2.079, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(1.4252,-3.3000,-8.8139);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 15 ) );
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(1.4252,-3.3000,8.8163);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 16 ) );
   tp=p;
    tp = tp + vec3(5.2596,-5.0000,-0.7289);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.148, 4.950, 3.960 ), 0.0 ) ) - 0.010, 0, 17 ) );
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(-2.2887,-7.8380,-4.8469);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(3.4117,-5.0000,-4.8422);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.980, 4.950, 0.148 ), 0.0 ) ) - 0.010, 0, 19 ) );
   tp=p;
    tp = tp + vec3(4.2562,-7.8380,-4.4534);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4907,-7.8383,-5.0876);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.495, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2562,-3.2000,-4.4534);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4907,-3.2000,-5.0876);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.495, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(0.9224,-5.2000,-4.1389);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.838, 5.148, 1.660 ), 0.0 ) ) - 0.010, 0, 24 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-5.2000,0.2454);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 5.148, 0.198 ), 0.0 ) ) - 0.010, 0, 25 ) );
   tp=p;
    tp = tp + vec3(9.3180,-5.2000,3.5272);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.198, 5.148, 3.255 ), 0.0 ) ) - 0.010, 0, 26 ) );
   tp=p;
    tp = tp + vec3(-9.3180,-5.2000,3.5272);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.198, 5.148, 3.255 ), 0.0 ) ) - 0.010, 0, 27 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-5.2000,6.6260);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 5.148, 0.198 ), 0.0 ) ) - 0.010, 0, 28 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-10.4889,3.3101);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 0.099, 3.255 ), 0.0 ) ) - 0.010, 0, 29 ) );
   tp=p;
    tp = tp + vec3(7.4331,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-1.0780,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-4.5929,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-8.0199,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-4.9243,-5.9269,-4.1547);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 35 ) );
   tp=p;
    tp = tp + vec3(-3.0304,-3.3000,-6.6025);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.402, 2.475, 0.653 ), 0.0 ) ) - 0.010, 0, 36 ) );
   tp=p;
    tp = tp + vec3(-8.5374,-3.2000,-6.6025);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.402, 2.475, 0.653 ), 0.0 ) ) - 0.010, 0, 37 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(3.4808,-9.7717,-1.1778);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.383, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 39 ) );
   tp=p;
    tp = tp + vec3(7.3254,-5.9269,0.0587);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.123, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 40 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 42 ) );
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 44 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 46 ) );
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 48 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.5424);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.485, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 50 ) );
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.5424);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.4095);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 52 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-4.6197,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 54 ) );
   tp=p;
    tp = tp + vec3(-4.6197,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-4.6197,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 56 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-1.1052,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 58 ) );
   tp=p;
    tp = tp + vec3(-1.1052,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-1.1052,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 60 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-8.0062,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 62 ) );
   tp=p;
    tp = tp + vec3(-8.0062,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-8.0062,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 64 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.594, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 66 ) );
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.297, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.297, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 68 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.594, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 70 ) );
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.297, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.297, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 72 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(7.4230,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 74 ) );
   tp=p;
    tp = tp + vec3(7.4230,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(7.4230,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 76 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.5246);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.475, 1.980, 0.198 ), 0.0 ) ) - 0.010, 0, 78 ) );
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.5246);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.178, 1.782, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.3917);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.178, 1.980, 0.148 ), 0.0 ) ) - 0.010, 0, 80 ) );
    res=opU( res, gResult1 );
   tp=p;
    tp = tp + vec3(-3.9968,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 82 ) );
   tp=p;
    tp = tp + vec3(-5.0704,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 83 ) );
   tp=p;
    tp = tp + vec3(-6.1014,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 84 ) );
   tp=p;
    tp = tp + vec3(-7.1090,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 85 ) );
   tp=p;
    tp = tp + vec3(-8.3756,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 86 ) );
   tp=p;
    res=opU( res, vec3( tp.y + 0.000, 0, 87 ) );
    return res;
}


uniform sampler2D uRO, uRD, uHit, uNormal;

uniform int uOffset, uStep;
uniform float uTMin, uTMax;
uniform float uStepSize;

layout(location=0) out vec4 outHit;
layout(location=1) out vec4 outNormal;

vec3 calcNormalA(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x
    );
    return normalize(nor);
}

const int NORMAL_STEPS = 6;

vec3 calcNormalB(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).x * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

/*
vec3 calc_normal(vec3 p) {

    vec3 epsilon = vec3(0.001, 0., 0.);

    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,
                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,
                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);

    return normalize(n);
}*/

vec3 castRay( in vec3 ro, in vec3 rd, in float tmax, in vec3 res )
{
    float t=res.x, m=res.y, id=res.z;

    for( int i = uOffset; i < (uOffset + uStep); i++ )
    {
        float precis = 0.0001;// * t;

        vec3 res = map( ro+rd*t );
        // <! ABS !>
        // if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        if ( res.x <= precis ) {
            m = res.y;
            id = res.z;
            break;
        }
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}

void main()
{
    vec3 inRO = textureLod( uRO, vTexCoord, 0.0 ).xyz;
    vec3 inRD = textureLod( uRD, vTexCoord, 0.0 ).xyz;

    vec3 res, normal = vec3( 0 );

    if ( uOffset == 0 ) res = vec3( uTMin, -1, -1 );
    else {
        res = textureLod( uHit, vTexCoord, 0.0 ).xyz;
        normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

        if ( res.y >= 0.0 ) {
            outHit = vec4( res, 1.0 );
            outNormal = vec4( normal, 1.0 );
            return;
        }
    }

    vec3 hit = castRay( inRO, inRD, uTMax, res );
    if ( hit.y >= 0.0 ) {
        normal = calcNormalB( inRO + inRD * hit.x );
    }

    outHit = vec4( hit, 1.0 );
    outNormal = vec4( normal, 1.0 );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision mediump float;

in vec2 vTexCoord;

uniform vec3 uSunDir;
uniform bool uSunActive;

uniform float uStepSize, uTMin, uTMax;
uniform int uSteps;


struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3  emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};



#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];




// --- Structs

struct Ray {
    vec3 origin;
    vec3 dir;
};

uniform float uSelectedId;

// --- Grid

uniform bool uGrid;
uniform float uGridSize;
uniform float uGridDim;

#define GRID_COLOR_1 vec4( 0.35, 0.35, 0.35, 0 )
#define GRID_COLOR_2 vec4( 0.35, 0.35, 0.35, 1.0 )

#define RED_COLOR_1 vec4( 0 )
#define RED_COLOR_2 vec4( 189.0*0.5/255.0, 33.0*0.5/255.0, 33.0*0.5/255.0, 1 )

#define BLUE_COLOR_1 vec4( 0 )
#define BLUE_COLOR_2 vec4( 68.0*0.5/255.0, 69.0*0.5/255.0, 198.0*0.5/255.0, 1 )

#define YELLOW_COLOR_1 vec4( 0 )
#define YELLOW_COLOR_2 vec4( 219.0*0.5/255.0, 217.0*0.5/255.0, 42.0*0.5/255.0, 1 )

#define GRID_LINE_SIZE 1.5

const vec3 L = normalize(vec3(-0.5, 0.3, 0.7));
const vec3 L1 = normalize(vec3(0.5, -0.5, -0.5));
const vec3 L2 = normalize(vec3(0, 0.5, 0));

// ---

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;

vec4 getColor( in Ray ray, in vec3 hit )
{
    vec4 color = vec4( 0.0 );

    MaterialInfo material;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
    {
        int matIndex=int( hit.y );
        material = uMaterials[matIndex];
    }

    float planeD = 1000.0;
    if ( uGrid )
    {
        float denom = dot( ray.dir, vec3( 0, 1, 0 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 1, 0 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( p.x <= uGridDim && p.x >= -uGridDim && p.z <= uGridDim && p.z >= -uGridDim )
                {
                    vec2 uv = abs(mod(p.xz + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xz);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, gln));

                    if ( p.z > 0.0 && abs( p.x ) < 0.1 ) {

                        vec4 blendColor = mix(BLUE_COLOR_1, BLUE_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    if ( p.x > 0.0 && abs( p.z ) < 0.1 ) {

                        vec4 blendColor = mix(RED_COLOR_1, RED_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.y / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );
                    }
                    planeD = t;
                }
            }
        }

        denom = dot( ray.dir, vec3( 0, 0, 1 ) );
        if ( denom != 0.0 )
        {
            float t = -( dot( ray.origin, vec3( 0, 0, 1 )  ) ) / denom;

            if ( t >= 0.0 )
            {
                vec3 p = ray.origin + t * ray.dir;

                if ( /*t < planeD &&*/ p.y <= uGridDim && p.y >= 0.0 )
                {
                    vec2 uv = abs(mod(p.xy + uGridSize/2.0, uGridSize) - uGridSize/2.0);

                    uv /= fwidth(p.xy);
                    float gln = min(uv.x, uv.y) / uGridSize;

                    if ( abs( p.x ) < 0.1 )
                    {
                        vec4 blendColor = mix(YELLOW_COLOR_1, YELLOW_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / uGridSize, uv.x / uGridSize ));

                        color.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a);
                        color.x = ( blendColor.x ) + (color.x * (1.0 - blendColor.a ) );
                        color.y = ( blendColor.y ) + (color.y * (1.0 - blendColor.a ) );
                        color.z = ( blendColor.z ) + (color.z * (1.0 - blendColor.a ) );

                        if ( blendColor.a > 0.9 )
                            planeD = t;
                    }
                }
            }
        }
    }

    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;
    if ( hit.y >= 0.0 && ( hit.x < planeD || color.a < 0.8 ) )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;

        

        if ( hit.z == uSelectedId )
        {
            material.baseColor = vec3( 0.5, 0.5, 1.0 );
            color = vec4( material.baseColor * vec3(0.5, 0.5, 1.0) * clamp(dot(L, normal), 0.3, 1.0), 1.0 );
        } else
        {
            color = vec4( material.baseColor * clamp(max(max(dot(L, normal),dot(L1, normal)), dot(L2, normal)), 0.3, 1.0), 1.0 );
        }
    }

    

    return color;
}

out vec4 outColor;

void main()
{
    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );

    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;

    outColor = getColor( Ray( inRO.xyz, inRD.xyz ), hit );
    outColor = vec4( clamp( pow( outColor.xyz, vec3(0.4545) ), 0.0, 1.0 ), outColor.a );
}

__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

layout(location=0) out vec4 ro;
layout(location=1) out vec4 rd;
// layout(location=2) out vec4 tcol;
// layout(location=3) out vec4 fcol;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform float uTime;
uniform bool uJitter;

vec2 randv2;

vec2 rand2() {// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html
    randv2 += vec2(1.0,1.0);
    return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453), fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));
}

void main()
{
    // --- Setup Camera

    float ratio = inResolution.x / inResolution.y;
    vec2 pixelSize = vec2(1.0) / inResolution.xy;

    randv2 = fract(cos((vTexCoord.xy+vTexCoord.yx*vec2(1000.0,1000.0))+vec2(uTime)*10.0));

    float halfWidth = tan(radians(uFov) * 0.5);
    float halfHeight = halfWidth / ratio;

    vec3 upVector = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(uOrigin - uLookAt);
    vec3 u = cross(upVector, w);
    vec3 v = cross(w, u);

    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = u * halfWidth * 2.0;
    vec3 vertical = v * halfHeight * 2.0;

    // ---

    vec3 dir = lowerLeft - uOrigin;
    vec2 rand;

    if ( uJitter ) rand = rand2();
    else rand = vec2( 0.5 );

    dir += horizontal * (pixelSize.x * rand.x + vTexCoord.x);
    dir += vertical * (pixelSize.y * rand.y + 1.0 - vTexCoord.y);

    // ---

    ro = vec4( uOrigin, 0 );
    rd = vec4( normalize( dir ), 0 );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform sampler2D uTCol, uFCol;
uniform sampler2D uLast;

uniform int uIter;
uniform int uColorMode;

out vec4 outColor;

vec3 Tonemap_ACES(const vec3 x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

void main()
{
    vec4 tcol = textureLod( uTCol, vTexCoord, 0.0 );
    vec4 color = vec4( tcol.xyz, 1. );

    if ( uColorMode == 0 )
        outColor = color;
    else
    if ( uColorMode == 1 )
        outColor = vec4( clamp( pow( color.xyz, vec3(0.4545) ), 0.0, 1.0 ), 1.0 );
    else
    if ( uColorMode == 2 )
        outColor = vec4( clamp( Tonemap_ACES( color.xyz ), 0.0, 1.0 ), 1.0 );

    if ( uIter > 0 ) {
        vec4 lastColor = textureLod( uLast, vTexCoord, 0.0 );//.xyz;

        float weight = float(uIter+1);
        outColor = vec4( mix(lastColor.xyz, outColor.xyz, 1.0 / weight ), 1.0 );
    }
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}

#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];






#define SAMPLES 1
#define MAXDEPTH 4

#define PI 3.14159265359
#define TWO_PI 6.28318
#define NUM_SPHERES 7

#define WALL_LEFT_ID 1.
#define WALL_RIGHT_ID 2.
#define WALL_FRONT_ID 3.
#define WALL_BACK_ID 4.
#define WALL_TOP_ID 5.
#define WALL_BOTTOM_ID 6.
#define LIGHT_ID 7.
#define SPHERE_ID1 8.
#define SPHERE_ID2 9.

#define LIGHT_TYPE_SPHERE 0
#define LIGHT_TYPE_SUN    1

#define EPSILON 0.0001
#define INFINITY 1000000.

#define RAY_MARCH_STEPS 100

#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))

#define Le vec3(40.)

/* Sun/Directional Light Parameters

SUN_DIRECTION 	- Mean direction
SUN_SOLID_ANGLE - The solid angle sun subtens at eye. higher value will create softer shadows.
sunLe			- Radiance

*/

#define SUN_DIRECTION vec3(1.,1.,1.)
#define SUN_SOLID_ANGLE 6.87E-5
#define sunLe vec3(20000.)

// struct Ray { vec3 o, d; };

struct LightInfo {
    vec3 L;
    vec3 position;
    vec3 direction;
    float radius;
    int type;
    bool enabled;
};

struct Sphere {
	float r;
	vec3 p;
};

struct Plane {
	vec3 p;
	vec4 n;
};

struct RaySampleInfo {
    vec3 origin;
    vec3 direction;
    vec2 imagePlaneUV;
};

Sphere spheres[NUM_SPHERES];
Plane  planes[6];
float seed = 0.;

#define NUM_LIGHTS 2
LightInfo lights[NUM_LIGHTS];

struct SurfaceInteraction {
    float id;
    vec3 incomingRayDir;
    vec3 point;
    vec3 normal;
    float objId;
};

#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInteraction(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, -10.)

///////////////////////////////////////////////////////////////////////
//////////////////////// Utility Functions ///////////////////////////
///////////////////////////////////////////////////////////////////////

vec3 linearToGamma(const in vec3 linearColor) {
   return pow(linearColor, vec3(0.4545));
}

vec3 gammaToLinear(const in vec3 gammaColor) {
   return pow(gammaColor, vec3(2.2));
}

#define HASHSCALE3 vec3(.1031, .1030, .0973)
vec2 hash21(float p) {
    vec3 p3 = fract(vec3(p) * HASHSCALE3);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));
}

#define HASHSCALE1 .1031
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float random() {
   return fract(sin(seed++)*43758.5453123);
}

float distanceSq(vec3 v1, vec3 v2) {
    vec3 d = v1 - v2;
    return dot(d, d);
}

float sqr(float x) {
    return x*x;
}

void CoordinateSystem(vec3 normal, out vec3 tangent, out vec3 binormal){
    if (abs(normal.x) > abs(normal.y)) {
        tangent = normalize(vec3(-normal.z, 0., normal.x));
    }
    else {
        tangent = normalize(vec3(0., normal.z, -normal.y));
    }

    binormal = cross(normal, tangent);
}

vec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {
    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
}

vec3 uniform_sample_cone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * TWO_PI;
    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

bool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {
    return dot(wo, normal) * dot(wi, normal) > 0.0;
}

vec2 concentricSampleDisk(const in vec2 u) {
    vec2 uOffset = 2. * u - vec2(1., 1.);

    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);

    float theta, r;
    if (abs(uOffset.x) > abs(uOffset.y)) {
        r = uOffset.x;
        theta = PI/4. * (uOffset.y / uOffset.x);
    } else {
        r = uOffset.y;
        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);
    }
    return r * vec2(cos(theta), sin(theta));
}

vec3 cosineSampleHemisphere(const in vec2 u) {
    vec2 d = concentricSampleDisk(u);
    float z = sqrt(max(0., 1. - d.x * d.x - d.y * d.y));
    return vec3(d.x, d.y, z);
}

vec3 uniformSampleHemisphere(const in vec2 u) {
    float z = u[0];
    float r = sqrt(max(0., 1. - z * z));
    float phi = 2. * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}
///////////////////////////////////////////////////////////////////////
///////////// DISTANCE FIELDS AND RAY MARCHING ////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////  PDF's and BRDF's  ////////////////////////////
///////////////////////////////////////////////////////////////////////

float schlickWeight(float cosTheta) {
    float m = clamp(1. - cosTheta, 0., 1.);
    return (m * m) * (m * m) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.) return 1./PI;
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return (a2-1.) / (PI*log(a2)*t);
}

float GTR2(float NdotH, float a) {
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return a2 / (PI * t*t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1. / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG) {
    float a = alphaG*alphaG;
    float b = NdotV*NdotV;
    return 1. / (NdotV + sqrt(a + b - a*b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {
    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));
}

float pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {
    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;
}

float pdfMicrofacet(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;
    vec3 wh = normalize(wo + wi);

    float NdotH = dot(interaction.normal, wh);
    float alpha2 = material.roughness * material.roughness;
    alpha2 *= alpha2;

    float cos2Theta = NdotH * NdotH;
    float denom = cos2Theta * ( alpha2 - 1.) + 1.;
    //if( denom == 0. ) return 0.;
    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);
    return pdfDistribution/(4. * dot(wo, wh));
}

float pdfClearCoat(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;

    vec3 wh = wi + wo;
    wh = normalize(wh);

    float Dr = GTR1(abs(dot(wh, interaction.normal)), material.roughness);
    return Dr / (4. * dot(wo, wh));
}

vec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);

    float Fd90 = 0.5 + 2. * LdotH*LdotH * material.roughness;
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    return (1./PI) * Fd * material.baseColor;
}

vec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);


    float Fss90 = LdotH*LdotH*material.roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);

    return (1./PI) * ss * material.baseColor;
}

vec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float a = max(.001, sqr(material.roughness));
    float Ds = GTR2(NdotH, a);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX(NdotL, a);
    Gs *= smithG_GGX(NdotV, a);

    return Gs*Fs*Ds;
}

vec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material,
                                 const in vec3 L, const in vec3 V,
                                 const in vec3 H, const in vec3 X, const in vec3 Y) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float aspect = sqrt(1.-material.anisotropic*.9);
    float ax = max(.001, sqr(material.roughness)/aspect);
    float ay = max(.001, sqr(material.roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    return Gs*Fs*Ds;
}

float disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {
    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(.1,.001,material.clearcoatGloss));
    float FH = schlickWeight(LdotH);
    float Fr = mix(.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);
    return .25 * material.clearcoat*Gr*Fr*Dr;
}

vec3 disneySheen(float LdotH, const in MaterialInfo material) {
    float FH = schlickWeight(LdotH);
    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g  + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Csheen = mix(vec3(1.), Ctint, material.sheenTint);
    vec3 Fsheen = FH * material.sheen * Csheen;
    return FH * material.sheen * Csheen;
}


vec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed ) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = normalize(light.position - interaction.point);
    CoordinateSystem(ldir, tangent, binormal);

    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / (TWO_PI * (1. - cosThetaMax));
    }

	return light.L;
}

vec3 sampleSun(const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = light.direction;
    CoordinateSystem(ldir, tangent, binormal);

    float cosThetaMax = 1. - SUN_SOLID_ANGLE/TWO_PI;
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / SUN_SOLID_ANGLE;
    }

	return light.L;
}

vec3 lightLe( vec4 light, const in SurfaceInteraction interaction, out float lightPdf ) {
	return Le;
}

float lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {
	float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax));
}

vec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if( !sameHemiSphere(wo, wi, interaction.normal) )
        return vec3(0.);

	float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) return vec3(0.);

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);
    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);
    vec3 glossy = disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);
    vec3 sheen = disneySheen(LdotH, material);

    return ( mix(diffuse, subSurface, material.subsurface) + sheen * 0. ) * (1. - material.metallic) + glossy + clearCoat * 0.;
}

#define cosineSample() \
	vec3 wiLocal = cosineSampleHemisphere(u); \
	vec3 tangent = vec3(0.), binormal = vec3(0.);\
	CoordinateSystem(normal, tangent, binormal);\
	wi = wiLocal.x * tangent + wiLocal.y * binormal + wiLocal.z * normal;\
    if (dot(wo, normal) < 0.) wi.z *= -1.;\
    float NdotL = dot(normal, wo);\
    float NdotV = dot(normal, wi);\
    if (NdotL < 0. || NdotV < 0.) {\
       pdf = 0.;\
       return vec3(0.);\
    }

vec3 disneyDiffuseSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneyDiffuse(NdotL, NdotV, LdotH, material) * (1. - material.subsurface);
}

vec3 disneySubSurfaceSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float NdotH = dot(normal,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySubsurface(NdotL, NdotV, NdotH, material) * material.subsurface;
}

vec3 disneySheenSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySheen(LdotH, material);
}

vec3 disneyMicrofacetSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    float cosTheta = 0., phi = (2. * PI) * u[1];
    float alpha = material.roughness * material.roughness;
    float tanTheta2 = alpha * alpha * u[0] / (1.0 - u[0]);
    cosTheta = 1. / sqrt(1. + tanTheta2);

    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));
    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    CoordinateSystem(interaction.normal, tangent, binormal);

    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * interaction.normal;

    if(!sameHemiSphere(wo, wh, interaction.normal)) {
       wh *= -1.;
    }

    wi = reflect(-wo, wh);

    float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) {
        pdf = 0.; // If not set to 0 here, create's artifacts. WHY EVEN IF SET OUTSIDE??
        return vec3(0.);
    }

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    pdf = pdfMicrofacet(wi, wo, interaction, material);
    return disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
}

vec3 disneyClearCoatSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {
    // TODO:: Implement!!
    return vec3(0.);
}

float bsdfPdf(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    // Pdf's for Sheen, Subsurface and Diffuse are same
    float pdfDiffuse = pdfLambertianReflection(wi, wo, interaction.normal);
    float pdfMicrofacet = pdfMicrofacet(wi, wo, interaction, material);
    float pdfClearCoat = pdfClearCoat(wi, wo, interaction, material);;
	//return (pdfDiffuse * 3. + pdfMicrofacet + pdfClearCoat)/5.;
    return (pdfDiffuse * 1. + pdfMicrofacet)/2.;
}

// TODO:: Check this function carefully
vec3 bsdfSample(out vec3 wi, const in vec3 wo, out float pdf, const in SurfaceInteraction interaction, const in MaterialInfo material) {

    vec3 f = vec3(0.);
    pdf = 0.0;

    vec2 u = vec2(random(), random());
	if( random() < 0.5 ) {
       f = disneyDiffuseSample(wi, wo, pdf, u, interaction.normal, material);
    }
    else {
       f = disneyMicrofacetSample(wi, wo, pdf, u, interaction, material);
    }

    f = bsdfEvaluate(wi, wo, interaction, material);
    //pdf = bsdfPdf(wi, wo, interaction, material);
    if( pdf == 0.)
        return vec3(0.);
	return f;
}

vec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed) {
    if( !light.enabled )
        return vec3(0.);

    if( light.type == LIGHT_TYPE_SPHERE ) {
        vec3 L = lightSample(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTest(interaction.point + wi * .01, wi);
        return L;
    }
    else if( light.type == LIGHT_TYPE_SUN ) {
        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTestSun(interaction.point + wi * .01, wi);
        return L;
    }
    else {
        return vec3(0.);
    }
}

vec3 estimateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material) {
	// Sample light source with multiple importance sampling
    vec3 wi;
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., scatteringPdf = 0., visibility = 0.;

    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;

    bool isBlack = dot(Li, Li) == 0.;

    if (lightPdf > 0. && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction, material) * abs(dot(wi, interaction.normal));
        scatteringPdf = bsdfPdf(wi, wo, interaction, material);

		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           float weight = 1.;//powerHeuristic(1., lightPdf, 1., scatteringPdf);
           Ld += f * Li * weight / lightPdf;
        }
    }

    // Sample BSDF with multiple importance sampling
    /*vec3 f;
    bool sampledSpecular = false;
    // Sample scattered direction for surface interactions
    BxDFType sampledType;
    f = bsdfSample(isect.wo, wi, uScattering, &scatteringPdf, bsdfFlags, &sampledType);
    f *= abs(dot(wi, isect.shading.n);
	bool isBlack = dot(Li, Li) == 0.;
    sampledSpecular = (sampledType & BSDF_SPECULAR) != 0;

    if (!isBlack && scatteringPdf > 0) {
    // Account for light contributions along sampled direction _wi_
    	float weight = 1.;
    	if (!sampledSpecular) {
            lightPdf = light.Pdf_Li(it, wi);
            if (lightPdf == 0) return Ld;
            weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
        }

        SurfaceInteraction interaction;
        bool foundSurfaceInteraction = false;
        // Add light contribution from material sampling
        vec3 Li(0.f);
        if (foundSurfaceInteraction) {
            if (lightIsect.primitive->GetAreaLight() == &light)
                Li = lightIsect.Le(-wi);
        } else
            Li = light.Le(ray);
        if (!Li.IsBlack()) Ld += f * Li * Tr * weight / scatteringPdf;
    }*/
    return Ld;
}


#define STOP_CODE -100000.0

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;

layout(location=0) out vec4 ro;
layout(location=1) out vec4 rd;

void getColor( inout Ray ray )
{
    MaterialInfo material;

    // vec3 hit = hitScene( ray.origin, ray.dir, material, normal );
    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;
    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
        material = uMaterials[int(hit.y)];

    if ( hit.y >= 0.0 )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;

        

        if ( material.type == 0 )
        {
            // Disney

            SurfaceInteraction interaction;
            interaction.point = hitOrigin;
            interaction.incomingRayDir = ray.dir;
            interaction.normal = normal;

            vec3 wo = -interaction.incomingRayDir, wi;
            float pdf = 0.;

            vec3 f = bsdfSample( wi, wo, pdf, interaction, material );
            ray = Ray( interaction.point/* + 1. * wi*/, wi );
        } else
        if ( material.type == 2 )
        {
            // --- Light
            ray = Ray( vec3( -100000 ), vec3( -100000 ) );
        }
    } else ray = Ray( vec3( -100000 ), vec3( -100000 ) );
}

void main()
{
    //randv2 = fract(cos((vTexCoord.xy+vTexCoord.yx*vec2(1000.0,1000.0))+vec2(uTime)*10.0));
    seed = float( uTime ) + hash12( vTexCoord );

    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );

    Ray ray = Ray( inRO.xyz, inRD.xyz );

    if ( inRO.x != STOP_CODE && inRD.x != STOP_CODE ) {
        getColor( ray );

        ro = vec4( ray.origin, 1. );
        rd = vec4( normalize( ray.dir ), 1. );
    } else {
        ro = inRO;
        rd = inRD;
    }
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];




#define SAMPLES 1
#define MAXDEPTH 4

#define PI 3.14159265359
#define TWO_PI 6.28318
#define NUM_SPHERES 7

#define WALL_LEFT_ID 1.
#define WALL_RIGHT_ID 2.
#define WALL_FRONT_ID 3.
#define WALL_BACK_ID 4.
#define WALL_TOP_ID 5.
#define WALL_BOTTOM_ID 6.
#define LIGHT_ID 7.
#define SPHERE_ID1 8.
#define SPHERE_ID2 9.

#define LIGHT_TYPE_SPHERE 0
#define LIGHT_TYPE_SUN    1

#define EPSILON 0.0001
#define INFINITY 1000000.

#define RAY_MARCH_STEPS 100

#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))

#define Le vec3(40.)

/* Sun/Directional Light Parameters

SUN_DIRECTION 	- Mean direction
SUN_SOLID_ANGLE - The solid angle sun subtens at eye. higher value will create softer shadows.
sunLe			- Radiance

*/

#define SUN_DIRECTION vec3(1.,1.,1.)
#define SUN_SOLID_ANGLE 6.87E-5
#define sunLe vec3(20000.)

// struct Ray { vec3 o, d; };

struct LightInfo {
    vec3 L;
    vec3 position;
    vec3 direction;
    float radius;
    int type;
    bool enabled;
};

struct Sphere {
	float r;
	vec3 p;
};

struct Plane {
	vec3 p;
	vec4 n;
};

struct RaySampleInfo {
    vec3 origin;
    vec3 direction;
    vec2 imagePlaneUV;
};

Sphere spheres[NUM_SPHERES];
Plane  planes[6];
float seed = 0.;

#define NUM_LIGHTS 2
LightInfo lights[NUM_LIGHTS];

struct SurfaceInteraction {
    float id;
    vec3 incomingRayDir;
    vec3 point;
    vec3 normal;
    float objId;
};

#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInteraction(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, -10.)

///////////////////////////////////////////////////////////////////////
//////////////////////// Utility Functions ///////////////////////////
///////////////////////////////////////////////////////////////////////

vec3 linearToGamma(const in vec3 linearColor) {
   return pow(linearColor, vec3(0.4545));
}

vec3 gammaToLinear(const in vec3 gammaColor) {
   return pow(gammaColor, vec3(2.2));
}

#define HASHSCALE3 vec3(.1031, .1030, .0973)
vec2 hash21(float p) {
    vec3 p3 = fract(vec3(p) * HASHSCALE3);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));
}

#define HASHSCALE1 .1031
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float random() {
   return fract(sin(seed++)*43758.5453123);
}

float distanceSq(vec3 v1, vec3 v2) {
    vec3 d = v1 - v2;
    return dot(d, d);
}

float sqr(float x) {
    return x*x;
}

void CoordinateSystem(vec3 normal, out vec3 tangent, out vec3 binormal){
    if (abs(normal.x) > abs(normal.y)) {
        tangent = normalize(vec3(-normal.z, 0., normal.x));
    }
    else {
        tangent = normalize(vec3(0., normal.z, -normal.y));
    }

    binormal = cross(normal, tangent);
}

vec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {
    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
}

vec3 uniform_sample_cone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * TWO_PI;
    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

bool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {
    return dot(wo, normal) * dot(wi, normal) > 0.0;
}

vec2 concentricSampleDisk(const in vec2 u) {
    vec2 uOffset = 2. * u - vec2(1., 1.);

    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);

    float theta, r;
    if (abs(uOffset.x) > abs(uOffset.y)) {
        r = uOffset.x;
        theta = PI/4. * (uOffset.y / uOffset.x);
    } else {
        r = uOffset.y;
        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);
    }
    return r * vec2(cos(theta), sin(theta));
}

vec3 cosineSampleHemisphere(const in vec2 u) {
    vec2 d = concentricSampleDisk(u);
    float z = sqrt(max(0., 1. - d.x * d.x - d.y * d.y));
    return vec3(d.x, d.y, z);
}

vec3 uniformSampleHemisphere(const in vec2 u) {
    float z = u[0];
    float r = sqrt(max(0., 1. - z * z));
    float phi = 2. * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}
///////////////////////////////////////////////////////////////////////
///////////// DISTANCE FIELDS AND RAY MARCHING ////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////  PDF's and BRDF's  ////////////////////////////
///////////////////////////////////////////////////////////////////////

float schlickWeight(float cosTheta) {
    float m = clamp(1. - cosTheta, 0., 1.);
    return (m * m) * (m * m) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.) return 1./PI;
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return (a2-1.) / (PI*log(a2)*t);
}

float GTR2(float NdotH, float a) {
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return a2 / (PI * t*t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1. / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG) {
    float a = alphaG*alphaG;
    float b = NdotV*NdotV;
    return 1. / (NdotV + sqrt(a + b - a*b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {
    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));
}

float pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {
    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;
}

float pdfMicrofacet(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;
    vec3 wh = normalize(wo + wi);

    float NdotH = dot(interaction.normal, wh);
    float alpha2 = material.roughness * material.roughness;
    alpha2 *= alpha2;

    float cos2Theta = NdotH * NdotH;
    float denom = cos2Theta * ( alpha2 - 1.) + 1.;
    //if( denom == 0. ) return 0.;
    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);
    return pdfDistribution/(4. * dot(wo, wh));
}

float pdfClearCoat(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;

    vec3 wh = wi + wo;
    wh = normalize(wh);

    float Dr = GTR1(abs(dot(wh, interaction.normal)), material.roughness);
    return Dr / (4. * dot(wo, wh));
}

vec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);

    float Fd90 = 0.5 + 2. * LdotH*LdotH * material.roughness;
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    return (1./PI) * Fd * material.baseColor;
}

vec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);


    float Fss90 = LdotH*LdotH*material.roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);

    return (1./PI) * ss * material.baseColor;
}

vec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float a = max(.001, sqr(material.roughness));
    float Ds = GTR2(NdotH, a);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX(NdotL, a);
    Gs *= smithG_GGX(NdotV, a);

    return Gs*Fs*Ds;
}

vec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material,
                                 const in vec3 L, const in vec3 V,
                                 const in vec3 H, const in vec3 X, const in vec3 Y) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float aspect = sqrt(1.-material.anisotropic*.9);
    float ax = max(.001, sqr(material.roughness)/aspect);
    float ay = max(.001, sqr(material.roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    return Gs*Fs*Ds;
}

float disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {
    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(.1,.001,material.clearcoatGloss));
    float FH = schlickWeight(LdotH);
    float Fr = mix(.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);
    return .25 * material.clearcoat*Gr*Fr*Dr;
}

vec3 disneySheen(float LdotH, const in MaterialInfo material) {
    float FH = schlickWeight(LdotH);
    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g  + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Csheen = mix(vec3(1.), Ctint, material.sheenTint);
    vec3 Fsheen = FH * material.sheen * Csheen;
    return FH * material.sheen * Csheen;
}


vec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed ) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = normalize(light.position - interaction.point);
    CoordinateSystem(ldir, tangent, binormal);

    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / (TWO_PI * (1. - cosThetaMax));
    }

	return light.L;
}

vec3 sampleSun(const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = light.direction;
    CoordinateSystem(ldir, tangent, binormal);

    float cosThetaMax = 1. - SUN_SOLID_ANGLE/TWO_PI;
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / SUN_SOLID_ANGLE;
    }

	return light.L;
}

vec3 lightLe( vec4 light, const in SurfaceInteraction interaction, out float lightPdf ) {
	return Le;
}

float lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {
	float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax));
}

vec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if( !sameHemiSphere(wo, wi, interaction.normal) )
        return vec3(0.);

	float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) return vec3(0.);

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);
    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);
    vec3 glossy = disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);
    vec3 sheen = disneySheen(LdotH, material);

    return ( mix(diffuse, subSurface, material.subsurface) + sheen * 0. ) * (1. - material.metallic) + glossy + clearCoat * 0.;
}

#define cosineSample() \
	vec3 wiLocal = cosineSampleHemisphere(u); \
	vec3 tangent = vec3(0.), binormal = vec3(0.);\
	CoordinateSystem(normal, tangent, binormal);\
	wi = wiLocal.x * tangent + wiLocal.y * binormal + wiLocal.z * normal;\
    if (dot(wo, normal) < 0.) wi.z *= -1.;\
    float NdotL = dot(normal, wo);\
    float NdotV = dot(normal, wi);\
    if (NdotL < 0. || NdotV < 0.) {\
       pdf = 0.;\
       return vec3(0.);\
    }

vec3 disneyDiffuseSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneyDiffuse(NdotL, NdotV, LdotH, material) * (1. - material.subsurface);
}

vec3 disneySubSurfaceSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float NdotH = dot(normal,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySubsurface(NdotL, NdotV, NdotH, material) * material.subsurface;
}

vec3 disneySheenSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySheen(LdotH, material);
}

vec3 disneyMicrofacetSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    float cosTheta = 0., phi = (2. * PI) * u[1];
    float alpha = material.roughness * material.roughness;
    float tanTheta2 = alpha * alpha * u[0] / (1.0 - u[0]);
    cosTheta = 1. / sqrt(1. + tanTheta2);

    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));
    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    CoordinateSystem(interaction.normal, tangent, binormal);

    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * interaction.normal;

    if(!sameHemiSphere(wo, wh, interaction.normal)) {
       wh *= -1.;
    }

    wi = reflect(-wo, wh);

    float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) {
        pdf = 0.; // If not set to 0 here, create's artifacts. WHY EVEN IF SET OUTSIDE??
        return vec3(0.);
    }

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    pdf = pdfMicrofacet(wi, wo, interaction, material);
    return disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
}

vec3 disneyClearCoatSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {
    // TODO:: Implement!!
    return vec3(0.);
}

float bsdfPdf(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    // Pdf's for Sheen, Subsurface and Diffuse are same
    float pdfDiffuse = pdfLambertianReflection(wi, wo, interaction.normal);
    float pdfMicrofacet = pdfMicrofacet(wi, wo, interaction, material);
    float pdfClearCoat = pdfClearCoat(wi, wo, interaction, material);;
	//return (pdfDiffuse * 3. + pdfMicrofacet + pdfClearCoat)/5.;
    return (pdfDiffuse * 1. + pdfMicrofacet)/2.;
}

// TODO:: Check this function carefully
vec3 bsdfSample(out vec3 wi, const in vec3 wo, out float pdf, const in SurfaceInteraction interaction, const in MaterialInfo material) {

    vec3 f = vec3(0.);
    pdf = 0.0;

    vec2 u = vec2(random(), random());
	if( random() < 0.5 ) {
       f = disneyDiffuseSample(wi, wo, pdf, u, interaction.normal, material);
    }
    else {
       f = disneyMicrofacetSample(wi, wo, pdf, u, interaction, material);
    }

    f = bsdfEvaluate(wi, wo, interaction, material);
    //pdf = bsdfPdf(wi, wo, interaction, material);
    if( pdf == 0.)
        return vec3(0.);
	return f;
}

vec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed) {
    if( !light.enabled )
        return vec3(0.);

    if( light.type == LIGHT_TYPE_SPHERE ) {
        vec3 L = lightSample(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTest(interaction.point + wi * .01, wi);
        return L;
    }
    else if( light.type == LIGHT_TYPE_SUN ) {
        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTestSun(interaction.point + wi * .01, wi);
        return L;
    }
    else {
        return vec3(0.);
    }
}

vec3 estimateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material) {
	// Sample light source with multiple importance sampling
    vec3 wi;
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., scatteringPdf = 0., visibility = 0.;

    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;

    bool isBlack = dot(Li, Li) == 0.;

    if (lightPdf > 0. && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction, material) * abs(dot(wi, interaction.normal));
        scatteringPdf = bsdfPdf(wi, wo, interaction, material);

		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           float weight = 1.;//powerHeuristic(1., lightPdf, 1., scatteringPdf);
           Ld += f * Li * weight / lightPdf;
        }
    }

    // Sample BSDF with multiple importance sampling
    /*vec3 f;
    bool sampledSpecular = false;
    // Sample scattered direction for surface interactions
    BxDFType sampledType;
    f = bsdfSample(isect.wo, wi, uScattering, &scatteringPdf, bsdfFlags, &sampledType);
    f *= abs(dot(wi, isect.shading.n);
	bool isBlack = dot(Li, Li) == 0.;
    sampledSpecular = (sampledType & BSDF_SPECULAR) != 0;

    if (!isBlack && scatteringPdf > 0) {
    // Account for light contributions along sampled direction _wi_
    	float weight = 1.;
    	if (!sampledSpecular) {
            lightPdf = light.Pdf_Li(it, wi);
            if (lightPdf == 0) return Ld;
            weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
        }

        SurfaceInteraction interaction;
        bool foundSurfaceInteraction = false;
        // Add light contribution from material sampling
        vec3 Li(0.f);
        if (foundSurfaceInteraction) {
            if (lightIsect.primitive->GetAreaLight() == &light)
                Li = lightIsect.Le(-wi);
        } else
            Li = light.Le(ray);
        if (!Li.IsBlack()) Ld += f * Li * Tr * weight / scatteringPdf;
    }*/
    return Ld;
}




#define RENDER_ONLY 1
#define STOP_CODE -100000.0

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;
uniform int uLightIndex;

layout(location=0) out vec4 lightOrigin;
layout(location=1) out vec4 lightDir;
/*
#define PI 3.1415926535897932384626422832795028841971
vec2 randv2;

float random() {
    randv2+=vec2(1.0,0.0);
    // return fract(sin(dot(vTexCoord, vec2(12.9898, 78.233)) + seed++) * 43758.5453);
    return fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453);

}

vec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html
    randv2+=vec2(1.0,1.0);
    return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),
        fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));
}

vec3 tracerRandomBBoxSample( in vec3 bbox_min, in vec3 bbox_max )
{
    vec3 samples;
    samples.x = bbox_min.x + (bbox_max.x - bbox_min.x) * random();
    samples.y = bbox_min.y + (bbox_max.y - bbox_min.y) * random();
    samples.z = bbox_min.z + (bbox_max.z - bbox_min.z) * random();
    return samples;
}

vec3 tracerMidBBoxSample( in vec3 bbox_min, in vec3 bbox_max )
{
    vec3 samples;
    samples.x = bbox_min.x + (bbox_max.x - bbox_min.x) * 0.5;
    samples.y = bbox_min.y + (bbox_max.y - bbox_min.y) * 0.5;
    samples.z = bbox_min.z + (bbox_max.z - bbox_min.z) * 0.5;
    return samples;
}
*/
void setupLight( inout Ray ray, out vec4 ro, out vec4 rd )
{
    MaterialInfo material;

    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;
    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
        material = uMaterials[int(hit.y)];

    ro.a = 0.;

    if ( hit.y >= 0.0 )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;
        ro.xyz = hitOrigin;

        

        if ( material.type == 0 )
        {
            // --- Sample Light

            Light _light = uLights[uLightIndex];
            LightInfo light;

            light.L = material.emission;
            light.position = _light.pos;
            light.radius = _light.radius;
            light.type = LIGHT_TYPE_SPHERE;
            light.enabled = true;
            light.direction = uSunDir;

            SurfaceInteraction interaction;
            interaction.point = hitOrigin;
            interaction.incomingRayDir = ray.dir;
            interaction.normal = normal;

            float _seed = seed;

            vec3 wi;
            vec3 wo = -interaction.incomingRayDir;
            vec3 Ld = vec3(0.);
            float lightPdf = 0., scatteringPdf = 0.;


            vec3 Li;
            if ( !uSunActive ) Li = lightSample( light, interaction, wi, lightPdf, seed );
            else {
                light.L = vec3( 100000 ) * uSunStrength;
                Li = sampleSun( light, interaction, wi, lightPdf, seed );
            }

            ro.xyz = interaction.point;// + wi * .0001;
            ro.a = _seed;

            rd.xyz = wi;
            rd.a = _seed;
        }
    }
}

void main()
{
    //randv2 = fract(cos((vTexCoord.xy+vTexCoord.yx*vec2(1000.0,1000.0))+vec2(uTime)*10.0));
    seed = float( uTime ) + hash12( vTexCoord );

    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );
    vec4 ro, rd;

    Ray ray = Ray( inRO.xyz, inRD.xyz );

    if ( inRO.x != STOP_CODE && inRD.x != STOP_CODE ) setupLight( ray, ro, rd );
    else {
        ro = vec4( STOP_CODE );
        rd = vec4( STOP_CODE );
    }

    lightOrigin = ro;
    lightDir = rd;
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];





#define SAMPLES 1
#define MAXDEPTH 4

#define PI 3.14159265359
#define TWO_PI 6.28318
#define NUM_SPHERES 7

#define WALL_LEFT_ID 1.
#define WALL_RIGHT_ID 2.
#define WALL_FRONT_ID 3.
#define WALL_BACK_ID 4.
#define WALL_TOP_ID 5.
#define WALL_BOTTOM_ID 6.
#define LIGHT_ID 7.
#define SPHERE_ID1 8.
#define SPHERE_ID2 9.

#define LIGHT_TYPE_SPHERE 0
#define LIGHT_TYPE_SUN    1

#define EPSILON 0.0001
#define INFINITY 1000000.

#define RAY_MARCH_STEPS 100

#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))

#define Le vec3(40.)

/* Sun/Directional Light Parameters

SUN_DIRECTION 	- Mean direction
SUN_SOLID_ANGLE - The solid angle sun subtens at eye. higher value will create softer shadows.
sunLe			- Radiance

*/

#define SUN_DIRECTION vec3(1.,1.,1.)
#define SUN_SOLID_ANGLE 6.87E-5
#define sunLe vec3(20000.)

// struct Ray { vec3 o, d; };

struct LightInfo {
    vec3 L;
    vec3 position;
    vec3 direction;
    float radius;
    int type;
    bool enabled;
};

struct Sphere {
	float r;
	vec3 p;
};

struct Plane {
	vec3 p;
	vec4 n;
};

struct RaySampleInfo {
    vec3 origin;
    vec3 direction;
    vec2 imagePlaneUV;
};

Sphere spheres[NUM_SPHERES];
Plane  planes[6];
float seed = 0.;

#define NUM_LIGHTS 2
LightInfo lights[NUM_LIGHTS];

struct SurfaceInteraction {
    float id;
    vec3 incomingRayDir;
    vec3 point;
    vec3 normal;
    float objId;
};

#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInteraction(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, -10.)

///////////////////////////////////////////////////////////////////////
//////////////////////// Utility Functions ///////////////////////////
///////////////////////////////////////////////////////////////////////

vec3 linearToGamma(const in vec3 linearColor) {
   return pow(linearColor, vec3(0.4545));
}

vec3 gammaToLinear(const in vec3 gammaColor) {
   return pow(gammaColor, vec3(2.2));
}

#define HASHSCALE3 vec3(.1031, .1030, .0973)
vec2 hash21(float p) {
    vec3 p3 = fract(vec3(p) * HASHSCALE3);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));
}

#define HASHSCALE1 .1031
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float random() {
   return fract(sin(seed++)*43758.5453123);
}

float distanceSq(vec3 v1, vec3 v2) {
    vec3 d = v1 - v2;
    return dot(d, d);
}

float sqr(float x) {
    return x*x;
}

void CoordinateSystem(vec3 normal, out vec3 tangent, out vec3 binormal){
    if (abs(normal.x) > abs(normal.y)) {
        tangent = normalize(vec3(-normal.z, 0., normal.x));
    }
    else {
        tangent = normalize(vec3(0., normal.z, -normal.y));
    }

    binormal = cross(normal, tangent);
}

vec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {
    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
}

vec3 uniform_sample_cone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * TWO_PI;
    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

bool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {
    return dot(wo, normal) * dot(wi, normal) > 0.0;
}

vec2 concentricSampleDisk(const in vec2 u) {
    vec2 uOffset = 2. * u - vec2(1., 1.);

    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);

    float theta, r;
    if (abs(uOffset.x) > abs(uOffset.y)) {
        r = uOffset.x;
        theta = PI/4. * (uOffset.y / uOffset.x);
    } else {
        r = uOffset.y;
        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);
    }
    return r * vec2(cos(theta), sin(theta));
}

vec3 cosineSampleHemisphere(const in vec2 u) {
    vec2 d = concentricSampleDisk(u);
    float z = sqrt(max(0., 1. - d.x * d.x - d.y * d.y));
    return vec3(d.x, d.y, z);
}

vec3 uniformSampleHemisphere(const in vec2 u) {
    float z = u[0];
    float r = sqrt(max(0., 1. - z * z));
    float phi = 2. * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}
///////////////////////////////////////////////////////////////////////
///////////// DISTANCE FIELDS AND RAY MARCHING ////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////  PDF's and BRDF's  ////////////////////////////
///////////////////////////////////////////////////////////////////////

float schlickWeight(float cosTheta) {
    float m = clamp(1. - cosTheta, 0., 1.);
    return (m * m) * (m * m) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.) return 1./PI;
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return (a2-1.) / (PI*log(a2)*t);
}

float GTR2(float NdotH, float a) {
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return a2 / (PI * t*t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1. / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG) {
    float a = alphaG*alphaG;
    float b = NdotV*NdotV;
    return 1. / (NdotV + sqrt(a + b - a*b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {
    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));
}

float pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {
    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;
}

float pdfMicrofacet(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;
    vec3 wh = normalize(wo + wi);

    float NdotH = dot(interaction.normal, wh);
    float alpha2 = material.roughness * material.roughness;
    alpha2 *= alpha2;

    float cos2Theta = NdotH * NdotH;
    float denom = cos2Theta * ( alpha2 - 1.) + 1.;
    //if( denom == 0. ) return 0.;
    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);
    return pdfDistribution/(4. * dot(wo, wh));
}

float pdfClearCoat(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;

    vec3 wh = wi + wo;
    wh = normalize(wh);

    float Dr = GTR1(abs(dot(wh, interaction.normal)), material.roughness);
    return Dr / (4. * dot(wo, wh));
}

vec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);

    float Fd90 = 0.5 + 2. * LdotH*LdotH * material.roughness;
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    return (1./PI) * Fd * material.baseColor;
}

vec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);


    float Fss90 = LdotH*LdotH*material.roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);

    return (1./PI) * ss * material.baseColor;
}

vec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float a = max(.001, sqr(material.roughness));
    float Ds = GTR2(NdotH, a);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX(NdotL, a);
    Gs *= smithG_GGX(NdotV, a);

    return Gs*Fs*Ds;
}

vec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material,
                                 const in vec3 L, const in vec3 V,
                                 const in vec3 H, const in vec3 X, const in vec3 Y) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float aspect = sqrt(1.-material.anisotropic*.9);
    float ax = max(.001, sqr(material.roughness)/aspect);
    float ay = max(.001, sqr(material.roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    return Gs*Fs*Ds;
}

float disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {
    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(.1,.001,material.clearcoatGloss));
    float FH = schlickWeight(LdotH);
    float Fr = mix(.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);
    return .25 * material.clearcoat*Gr*Fr*Dr;
}

vec3 disneySheen(float LdotH, const in MaterialInfo material) {
    float FH = schlickWeight(LdotH);
    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g  + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Csheen = mix(vec3(1.), Ctint, material.sheenTint);
    vec3 Fsheen = FH * material.sheen * Csheen;
    return FH * material.sheen * Csheen;
}


vec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed ) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = normalize(light.position - interaction.point);
    CoordinateSystem(ldir, tangent, binormal);

    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / (TWO_PI * (1. - cosThetaMax));
    }

	return light.L;
}

vec3 sampleSun(const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = light.direction;
    CoordinateSystem(ldir, tangent, binormal);

    float cosThetaMax = 1. - SUN_SOLID_ANGLE/TWO_PI;
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / SUN_SOLID_ANGLE;
    }

	return light.L;
}

vec3 lightLe( vec4 light, const in SurfaceInteraction interaction, out float lightPdf ) {
	return Le;
}

float lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {
	float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax));
}

vec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if( !sameHemiSphere(wo, wi, interaction.normal) )
        return vec3(0.);

	float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) return vec3(0.);

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);
    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);
    vec3 glossy = disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);
    vec3 sheen = disneySheen(LdotH, material);

    return ( mix(diffuse, subSurface, material.subsurface) + sheen * 0. ) * (1. - material.metallic) + glossy + clearCoat * 0.;
}

#define cosineSample() \
	vec3 wiLocal = cosineSampleHemisphere(u); \
	vec3 tangent = vec3(0.), binormal = vec3(0.);\
	CoordinateSystem(normal, tangent, binormal);\
	wi = wiLocal.x * tangent + wiLocal.y * binormal + wiLocal.z * normal;\
    if (dot(wo, normal) < 0.) wi.z *= -1.;\
    float NdotL = dot(normal, wo);\
    float NdotV = dot(normal, wi);\
    if (NdotL < 0. || NdotV < 0.) {\
       pdf = 0.;\
       return vec3(0.);\
    }

vec3 disneyDiffuseSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneyDiffuse(NdotL, NdotV, LdotH, material) * (1. - material.subsurface);
}

vec3 disneySubSurfaceSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float NdotH = dot(normal,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySubsurface(NdotL, NdotV, NdotH, material) * material.subsurface;
}

vec3 disneySheenSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySheen(LdotH, material);
}

vec3 disneyMicrofacetSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    float cosTheta = 0., phi = (2. * PI) * u[1];
    float alpha = material.roughness * material.roughness;
    float tanTheta2 = alpha * alpha * u[0] / (1.0 - u[0]);
    cosTheta = 1. / sqrt(1. + tanTheta2);

    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));
    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    CoordinateSystem(interaction.normal, tangent, binormal);

    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * interaction.normal;

    if(!sameHemiSphere(wo, wh, interaction.normal)) {
       wh *= -1.;
    }

    wi = reflect(-wo, wh);

    float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) {
        pdf = 0.; // If not set to 0 here, create's artifacts. WHY EVEN IF SET OUTSIDE??
        return vec3(0.);
    }

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    pdf = pdfMicrofacet(wi, wo, interaction, material);
    return disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
}

vec3 disneyClearCoatSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {
    // TODO:: Implement!!
    return vec3(0.);
}

float bsdfPdf(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    // Pdf's for Sheen, Subsurface and Diffuse are same
    float pdfDiffuse = pdfLambertianReflection(wi, wo, interaction.normal);
    float pdfMicrofacet = pdfMicrofacet(wi, wo, interaction, material);
    float pdfClearCoat = pdfClearCoat(wi, wo, interaction, material);;
	//return (pdfDiffuse * 3. + pdfMicrofacet + pdfClearCoat)/5.;
    return (pdfDiffuse * 1. + pdfMicrofacet)/2.;
}

// TODO:: Check this function carefully
vec3 bsdfSample(out vec3 wi, const in vec3 wo, out float pdf, const in SurfaceInteraction interaction, const in MaterialInfo material) {

    vec3 f = vec3(0.);
    pdf = 0.0;

    vec2 u = vec2(random(), random());
	if( random() < 0.5 ) {
       f = disneyDiffuseSample(wi, wo, pdf, u, interaction.normal, material);
    }
    else {
       f = disneyMicrofacetSample(wi, wo, pdf, u, interaction, material);
    }

    f = bsdfEvaluate(wi, wo, interaction, material);
    //pdf = bsdfPdf(wi, wo, interaction, material);
    if( pdf == 0.)
        return vec3(0.);
	return f;
}

vec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed) {
    if( !light.enabled )
        return vec3(0.);

    if( light.type == LIGHT_TYPE_SPHERE ) {
        vec3 L = lightSample(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTest(interaction.point + wi * .01, wi);
        return L;
    }
    else if( light.type == LIGHT_TYPE_SUN ) {
        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTestSun(interaction.point + wi * .01, wi);
        return L;
    }
    else {
        return vec3(0.);
    }
}

vec3 estimateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material) {
	// Sample light source with multiple importance sampling
    vec3 wi;
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., scatteringPdf = 0., visibility = 0.;

    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;

    bool isBlack = dot(Li, Li) == 0.;

    if (lightPdf > 0. && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction, material) * abs(dot(wi, interaction.normal));
        scatteringPdf = bsdfPdf(wi, wo, interaction, material);

		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           float weight = 1.;//powerHeuristic(1., lightPdf, 1., scatteringPdf);
           Ld += f * Li * weight / lightPdf;
        }
    }

    // Sample BSDF with multiple importance sampling
    /*vec3 f;
    bool sampledSpecular = false;
    // Sample scattered direction for surface interactions
    BxDFType sampledType;
    f = bsdfSample(isect.wo, wi, uScattering, &scatteringPdf, bsdfFlags, &sampledType);
    f *= abs(dot(wi, isect.shading.n);
	bool isBlack = dot(Li, Li) == 0.;
    sampledSpecular = (sampledType & BSDF_SPECULAR) != 0;

    if (!isBlack && scatteringPdf > 0) {
    // Account for light contributions along sampled direction _wi_
    	float weight = 1.;
    	if (!sampledSpecular) {
            lightPdf = light.Pdf_Li(it, wi);
            if (lightPdf == 0) return Ld;
            weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
        }

        SurfaceInteraction interaction;
        bool foundSurfaceInteraction = false;
        // Add light contribution from material sampling
        vec3 Li(0.f);
        if (foundSurfaceInteraction) {
            if (lightIsect.primitive->GetAreaLight() == &light)
                Li = lightIsect.Le(-wi);
        } else
            Li = light.Le(ray);
        if (!Li.IsBlack()) Ld += f * Li * Tr * weight / scatteringPdf;
    }*/
    return Ld;
}


#define STOP_CODE -100000.0

uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;
uniform sampler2D uLightRO, uLightRD;
uniform sampler2D uLightHit;
uniform sampler2D uBRDF;
uniform int uLightIndex;

out vec4 outBRDF;

void sampleLight( in vec4 lro, in vec4 lrd, inout vec3 brdf )
{
    Light _light = uLights[uLightIndex];

    vec4 hit = textureLod( uHit, vTexCoord, 0.0 );
    vec4 lightHit = textureLod( uLightHit, vTexCoord, 0.0 );

    seed = lro.a;

    vec3 ro = textureLod( uRO, vTexCoord, 0.0 ).xyz;
    vec3 rd = textureLod( uRD, vTexCoord, 0.0 ).xyz;

    vec3 hitOrigin = ro + rd * hit.x;
    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

    SurfaceInteraction interaction;
    interaction.point = hitOrigin;
    interaction.incomingRayDir = rd;
    interaction.normal = normal;

    LightInfo light;
    MaterialInfo lightMaterial = uMaterials[int(lightHit.y)];

    light.L = lightMaterial.emission;
    light.position = _light.pos;
    light.radius = _light.radius;
    light.type = LIGHT_TYPE_SPHERE;
    light.enabled = true;
    light.direction = uSunDir;

    int matIndex = int( hit.y );
    MaterialInfo material = uMaterials[matIndex];
    

    vec3 wi;
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);

    float lightPdf = 0., scatteringPdf = 0.;
    vec3 Li;
    float visibility;

    if ( !uSunActive ) {
        visibility = _light.id == lightHit.z ? 1. : 0.;
        Li = lightSample( light, interaction, wi, lightPdf, seed );
    } else {
        light.L = vec3( 100000 ) * uSunStrength;
        visibility = lightHit.z < 0. ? 1. : 0.;
        Li = sampleSun( light, interaction, wi, lightPdf, seed );
    }

    bool isBlack = dot(Li, Li) == 0.;
    if (lightPdf > 0. && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction, material) * abs(dot(wi, interaction.normal));
        scatteringPdf = bsdfPdf(wi, wo, interaction, material);

        isBlack = dot(f, f) == 0.;
        if (!isBlack) {
            // Compute effect of visibility for light source sample
            Li *= visibility;//(interaction.point + wi * .01, wi);
            isBlack = dot(Li, Li) == 0.;
            // Add light's contribution to reflected radiance
            if (!isBlack) {
                float weight = 1.;//powerHeuristic(1., lightPdf, 1., scatteringPdf);
                Ld += f * Li * weight / lightPdf;
            }
        }
    }

    brdf += Ld;
}

void main()
{
    seed = uTime + hash12( vTexCoord );

    vec4 inRO = textureLod( uLightRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uLightRD, vTexCoord, 0.0 );

    vec3 brdf = vec3( 0 );

    if ( uLightIndex > 0 ) brdf = textureLod( uBRDF, vTexCoord, 0.0 ).xyz;
    if ( inRO.x != STOP_CODE && inRD.x != STOP_CODE ) sampleLight( inRO, inRD, brdf );

    outBRDF = vec4( brdf, inRO.a );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

uniform int uIter;
uniform float uTime, uRandom;
uniform sampler2D uLast;

uniform vec3 uMin, uMax;

uniform float uSelectedId;

uniform float uStepSize, uPrecision, uTMin, uTMax;
uniform int uSteps, uDepth, uColorMode;

uniform vec3 uSunDir;
uniform float uSunStrength;
uniform bool uSunActive;
uniform mat4 uInvertLocalTransform;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;
uniform vec3 uLocalScale;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

struct Light {
    bool  isActive;
    vec3  pos;
    float radius;
    float bbox_area;
    vec3  bbox_min, bbox_max;
    float id;
};


float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}

// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
const vec2 e = vec2(0, 1);

// Fabrices consice, 2D rotation formula.
mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }

// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the "sin" function
// tend to break down with large time values, so any hash function using "sin" probably
// can't be trusted in a product that requires accuracy.
vec3 hash(in vec3 p)
{
    float time = 0.0;

    p = vec3( dot(p,vec3(127.1, 311.7, 74.7)),
              dot(p,vec3(269.5, 183.3, 246.1)),
              dot(p,vec3(113.5, 271.9, 124.6)));

    p = fract(sin(p)*43758.5453123)*2. - 1.;

    mat2  m = r2(time*2.);//in general use 3d rotation
    p.xy = m * p.xy;//rotate gradient vector
    //p.yz = m * p.yz;//rotate gradient vector
    //p.zx = m * p.zx;//rotate gradient vector
    return p;
}

float gradNoise(in vec3 f){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy.
   const vec2 e = vec2(0, 1);

    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec3 p = floor(f);
    f -= p; // Fractional position within the cube.


    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing.
    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w;
// Super smooth, but less practical.
    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec3 w = f; // No smoothing. Gives a blocky appearance.

    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),
                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),
                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),
                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);

    // Taking the final result, and putting it into the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}
// Combining noise layers. Referred to as fractal Brownian motion, turbulence, etc.
float gradTurbulence(in vec3 p){

    // Three control factors. Lacunarity and gain are set to common defaults.
    const int layers = 5; //Noise layers. Also called octaves.
    const float lacunarity = 2.; // Frequency change factor. Controls the gaps.
    const float gain = .5; // Amplitue change factor. Controls granularity.

    float res = 0.; // Final result.
    float amp = 1.; // Initial amplitude.
    float tot = 0.; // Total amplitude. Used to normalize the final value.

    // Adding the layers of noise with varying frequencies and amplitudes.
    for(int i=0; i<layers; i++){

        res += gradNoise(p)*amp;  // Add noise layers at various amplitudes.
        p *= lacunarity; // Change the layer frequency.
        tot += amp; // Add the amplitude.
        amp *= gain; // Change the amplitude.

    }

    return res/tot; // Normalize and return. Range [0, 1]
}

#define MAX_MATERIALS 3
uniform MaterialInfo uMaterials[MAX_MATERIALS];

#define MAX_LIGHTS 1
uniform Light uLights[MAX_LIGHTS];





vec4 background( in vec3 ro, in vec3 rd, in vec3 sunDir ) {
  vec4 color=vec4(0,0,0,0);
  // fade the sky color, multiply sunset dimming
  vec3 finalColor = mix(vec4( 0.773, 0.710, 0.725, 1.000 ).xyz, vec4( 0.031, 0.329, 1.000, 1.000 ).xyz, pow(clamp(rd.y, 0.0, 1.0), 0.47))*0.95;
  // make clouds - just a horizontal plane with noise
  if ( rd.y > 0.0 )
  {
      float n = gradTurbulence( vec3(rd.xz/rd.y*1.0, 0.0 ) );
      n += gradTurbulence( vec3( rd.xz/rd.y*2.0, 0.0 ) )*0.5;
      n += gradTurbulence( vec3( rd.xz/rd.y*4.0, 0.0 ) )*0.25;
      n += gradTurbulence( vec3( rd.xz/rd.y*8.0, 0.0 ) )*0.125;
      n = pow(abs(n), 3.0);
      n = mix(n * 0.2, n, clamp(abs(rd.y * 8.0), 0.0, 1.0 ));  // fade clouds in distance
      finalColor = mix(finalColor, (vec3(1.0)+vec4( 0.176, 0.176, 0.176, 1.000 ).xyz*10.0)*0.75*clamp((rd.y+0.2)*5.0, 0.0, 1.0), clamp(n*0.125, 0.0, 1.0) );
      if ( uSunActive )
      {
          vec3 localRay = normalize(rd);
          float dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);
          float sunIntensity = 0.05 / dist;
          sunIntensity += exp(-dist*150.0) * (100.0 * (1.000));
          sunIntensity = min(sunIntensity, 40000.0);
          finalColor += vec4( 0.176, 0.176, 0.176, 1.000 ).xyz * sunIntensity*0.025;
          // Sun
          // float sundot = clamp(dot(rd, uSunDir), 0.0, 1.0);
          // finalColor += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);
          // finalColor += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);
      }
  }
color = vec4( finalColor.xyz, 1.0 );

return color;
}


#define RENDER_ONLY 1
#define STOP_CODE -100000.0

#define SAMPLES 1
#define MAXDEPTH 4

#define PI 3.14159265359
#define TWO_PI 6.28318
#define NUM_SPHERES 7

#define WALL_LEFT_ID 1.
#define WALL_RIGHT_ID 2.
#define WALL_FRONT_ID 3.
#define WALL_BACK_ID 4.
#define WALL_TOP_ID 5.
#define WALL_BOTTOM_ID 6.
#define LIGHT_ID 7.
#define SPHERE_ID1 8.
#define SPHERE_ID2 9.

#define LIGHT_TYPE_SPHERE 0
#define LIGHT_TYPE_SUN    1

#define EPSILON 0.0001
#define INFINITY 1000000.

#define RAY_MARCH_STEPS 100

#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))

#define Le vec3(40.)

/* Sun/Directional Light Parameters

SUN_DIRECTION 	- Mean direction
SUN_SOLID_ANGLE - The solid angle sun subtens at eye. higher value will create softer shadows.
sunLe			- Radiance

*/

#define SUN_DIRECTION vec3(1.,1.,1.)
#define SUN_SOLID_ANGLE 6.87E-5
#define sunLe vec3(20000.)

// struct Ray { vec3 o, d; };

struct LightInfo {
    vec3 L;
    vec3 position;
    vec3 direction;
    float radius;
    int type;
    bool enabled;
};

struct Sphere {
	float r;
	vec3 p;
};

struct Plane {
	vec3 p;
	vec4 n;
};

struct RaySampleInfo {
    vec3 origin;
    vec3 direction;
    vec2 imagePlaneUV;
};

Sphere spheres[NUM_SPHERES];
Plane  planes[6];
float seed = 0.;

#define NUM_LIGHTS 2
LightInfo lights[NUM_LIGHTS];

struct SurfaceInteraction {
    float id;
    vec3 incomingRayDir;
    vec3 point;
    vec3 normal;
    float objId;
};

#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInteraction(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, -10.)

///////////////////////////////////////////////////////////////////////
//////////////////////// Utility Functions ///////////////////////////
///////////////////////////////////////////////////////////////////////

vec3 linearToGamma(const in vec3 linearColor) {
   return pow(linearColor, vec3(0.4545));
}

vec3 gammaToLinear(const in vec3 gammaColor) {
   return pow(gammaColor, vec3(2.2));
}

#define HASHSCALE3 vec3(.1031, .1030, .0973)
vec2 hash21(float p) {
    vec3 p3 = fract(vec3(p) * HASHSCALE3);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));
}

#define HASHSCALE1 .1031
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float random() {
   return fract(sin(seed++)*43758.5453123);
}

float distanceSq(vec3 v1, vec3 v2) {
    vec3 d = v1 - v2;
    return dot(d, d);
}

float sqr(float x) {
    return x*x;
}

void CoordinateSystem(vec3 normal, out vec3 tangent, out vec3 binormal){
    if (abs(normal.x) > abs(normal.y)) {
        tangent = normalize(vec3(-normal.z, 0., normal.x));
    }
    else {
        tangent = normalize(vec3(0., normal.z, -normal.y));
    }

    binormal = cross(normal, tangent);
}

vec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {
    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
}

vec3 uniform_sample_cone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * TWO_PI;
    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

bool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {
    return dot(wo, normal) * dot(wi, normal) > 0.0;
}

vec2 concentricSampleDisk(const in vec2 u) {
    vec2 uOffset = 2. * u - vec2(1., 1.);

    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);

    float theta, r;
    if (abs(uOffset.x) > abs(uOffset.y)) {
        r = uOffset.x;
        theta = PI/4. * (uOffset.y / uOffset.x);
    } else {
        r = uOffset.y;
        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);
    }
    return r * vec2(cos(theta), sin(theta));
}

vec3 cosineSampleHemisphere(const in vec2 u) {
    vec2 d = concentricSampleDisk(u);
    float z = sqrt(max(0., 1. - d.x * d.x - d.y * d.y));
    return vec3(d.x, d.y, z);
}

vec3 uniformSampleHemisphere(const in vec2 u) {
    float z = u[0];
    float r = sqrt(max(0., 1. - z * z));
    float phi = 2. * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}
///////////////////////////////////////////////////////////////////////
///////////// DISTANCE FIELDS AND RAY MARCHING ////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////  PDF's and BRDF's  ////////////////////////////
///////////////////////////////////////////////////////////////////////

float schlickWeight(float cosTheta) {
    float m = clamp(1. - cosTheta, 0., 1.);
    return (m * m) * (m * m) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.) return 1./PI;
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return (a2-1.) / (PI*log(a2)*t);
}

float GTR2(float NdotH, float a) {
    float a2 = a*a;
    float t = 1. + (a2-1.)*NdotH*NdotH;
    return a2 / (PI * t*t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1. / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG) {
    float a = alphaG*alphaG;
    float b = NdotV*NdotV;
    return 1. / (NdotV + sqrt(a + b - a*b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {
    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));
}

float pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {
    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;
}

float pdfMicrofacet(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;
    vec3 wh = normalize(wo + wi);

    float NdotH = dot(interaction.normal, wh);
    float alpha2 = material.roughness * material.roughness;
    alpha2 *= alpha2;

    float cos2Theta = NdotH * NdotH;
    float denom = cos2Theta * ( alpha2 - 1.) + 1.;
    //if( denom == 0. ) return 0.;
    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);
    return pdfDistribution/(4. * dot(wo, wh));
}

float pdfClearCoat(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if (!sameHemiSphere(wo, wi, interaction.normal)) return 0.;

    vec3 wh = wi + wo;
    wh = normalize(wh);

    float Dr = GTR1(abs(dot(wh, interaction.normal)), material.roughness);
    return Dr / (4. * dot(wo, wh));
}

vec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);

    float Fd90 = 0.5 + 2. * LdotH*LdotH * material.roughness;
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    return (1./PI) * Fd * material.baseColor;
}

vec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH, const in MaterialInfo material) {

    float FL = schlickWeight(NdotL), FV = schlickWeight(NdotV);


    float Fss90 = LdotH*LdotH*material.roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);

    return (1./PI) * ss * material.baseColor;
}

vec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float a = max(.001, sqr(material.roughness));
    float Ds = GTR2(NdotH, a);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX(NdotL, a);
    Gs *= smithG_GGX(NdotV, a);

    return Gs*Fs*Ds;
}

vec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material,
                                 const in vec3 L, const in vec3 V,
                                 const in vec3 H, const in vec3 X, const in vec3 Y) {

    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Cspec0 = mix(material.specular *.08 * mix(vec3(1.), Ctint, material.specularTint), material.baseColor, material.metallic);

    float aspect = sqrt(1.-material.anisotropic*.9);
    float ax = max(.001, sqr(material.roughness)/aspect);
    float ay = max(.001, sqr(material.roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = schlickWeight(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    return Gs*Fs*Ds;
}

float disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH, const in MaterialInfo material) {
    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(.1,.001,material.clearcoatGloss));
    float FH = schlickWeight(LdotH);
    float Fr = mix(.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);
    return .25 * material.clearcoat*Gr*Fr*Dr;
}

vec3 disneySheen(float LdotH, const in MaterialInfo material) {
    float FH = schlickWeight(LdotH);
    float Cdlum = .3*material.baseColor.r + .6*material.baseColor.g  + .1*material.baseColor.b; // luminance approx.

    vec3 Ctint = Cdlum > 0. ? material.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat
    vec3 Csheen = mix(vec3(1.), Ctint, material.sheenTint);
    vec3 Fsheen = FH * material.sheen * Csheen;
    return FH * material.sheen * Csheen;
}


vec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed ) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = normalize(light.position - interaction.point);
    CoordinateSystem(ldir, tangent, binormal);

    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / (TWO_PI * (1. - cosThetaMax));
    }

	return light.L;
}

vec3 sampleSun(const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed) {
    vec2 u = vec2(random(), random());

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 ldir = light.direction;
    CoordinateSystem(ldir, tangent, binormal);

    float cosThetaMax = 1. - SUN_SOLID_ANGLE/TWO_PI;
    wi = uniform_sample_cone(u, cosThetaMax, tangent, binormal, ldir);

    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / SUN_SOLID_ANGLE;
    }

	return light.L;
}

vec3 lightLe( vec4 light, const in SurfaceInteraction interaction, out float lightPdf ) {
	return Le;
}

float lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {
	float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);
    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax));
}

vec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if( !sameHemiSphere(wo, wi, interaction.normal) )
        return vec3(0.);

	float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) return vec3(0.);

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);
    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);
    vec3 glossy = disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);
    vec3 sheen = disneySheen(LdotH, material);

    return ( mix(diffuse, subSurface, material.subsurface) + sheen * 0. ) * (1. - material.metallic) + glossy + clearCoat * 0.;
}

#define cosineSample() \
	vec3 wiLocal = cosineSampleHemisphere(u); \
	vec3 tangent = vec3(0.), binormal = vec3(0.);\
	CoordinateSystem(normal, tangent, binormal);\
	wi = wiLocal.x * tangent + wiLocal.y * binormal + wiLocal.z * normal;\
    if (dot(wo, normal) < 0.) wi.z *= -1.;\
    float NdotL = dot(normal, wo);\
    float NdotV = dot(normal, wi);\
    if (NdotL < 0. || NdotV < 0.) {\
       pdf = 0.;\
       return vec3(0.);\
    }

vec3 disneyDiffuseSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneyDiffuse(NdotL, NdotV, LdotH, material) * (1. - material.subsurface);
}

vec3 disneySubSurfaceSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float NdotH = dot(normal,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySubsurface(NdotL, NdotV, NdotH, material) * material.subsurface;
}

vec3 disneySheenSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {

    cosineSample()

    vec3 H = normalize(wo+wi);
    float LdotH = dot(wo,H);

    pdf = pdfLambertianReflection(wi, wo, normal);
    return disneySheen(LdotH, material);
}

vec3 disneyMicrofacetSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    float cosTheta = 0., phi = (2. * PI) * u[1];
    float alpha = material.roughness * material.roughness;
    float tanTheta2 = alpha * alpha * u[0] / (1.0 - u[0]);
    cosTheta = 1. / sqrt(1. + tanTheta2);

    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));
    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));

    vec3 tangent = vec3(0.), binormal = vec3(0.);
    CoordinateSystem(interaction.normal, tangent, binormal);

    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * interaction.normal;

    if(!sameHemiSphere(wo, wh, interaction.normal)) {
       wh *= -1.;
    }

    wi = reflect(-wo, wh);

    float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);

    if (NdotL < 0. || NdotV < 0.) {
        pdf = 0.; // If not set to 0 here, create's artifacts. WHY EVEN IF SET OUTSIDE??
        return vec3(0.);
    }

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);

    pdf = pdfMicrofacet(wi, wo, interaction, material);
    return disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH, material);
}

vec3 disneyClearCoatSample(out vec3 wi, const in vec3 wo, out float pdf, const in vec2 u, const in vec3 normal, const in MaterialInfo material) {
    // TODO:: Implement!!
    return vec3(0.);
}

float bsdfPdf(const in vec3 wi, const in vec3 wo, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    // Pdf's for Sheen, Subsurface and Diffuse are same
    float pdfDiffuse = pdfLambertianReflection(wi, wo, interaction.normal);
    float pdfMicrofacet = pdfMicrofacet(wi, wo, interaction, material);
    float pdfClearCoat = pdfClearCoat(wi, wo, interaction, material);;
	//return (pdfDiffuse * 3. + pdfMicrofacet + pdfClearCoat)/5.;
    return (pdfDiffuse * 1. + pdfMicrofacet)/2.;
}

// TODO:: Check this function carefully
vec3 bsdfSample(out vec3 wi, const in vec3 wo, out float pdf, const in SurfaceInteraction interaction, const in MaterialInfo material) {

    vec3 f = vec3(0.);
    pdf = 0.0;

    vec2 u = vec2(random(), random());
	if( random() < 0.5 ) {
       f = disneyDiffuseSample(wi, wo, pdf, u, interaction.normal, material);
    }
    else {
       f = disneyMicrofacetSample(wi, wo, pdf, u, interaction, material);
    }

    f = bsdfEvaluate(wi, wo, interaction, material);
    //pdf = bsdfPdf(wi, wo, interaction, material);
    if( pdf == 0.)
        return vec3(0.);
	return f;
}

vec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed) {
    if( !light.enabled )
        return vec3(0.);

    if( light.type == LIGHT_TYPE_SPHERE ) {
        vec3 L = lightSample(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTest(interaction.point + wi * .01, wi);
        return L;
    }
    else if( light.type == LIGHT_TYPE_SUN ) {
        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);
        // visibility = visibilityTestSun(interaction.point + wi * .01, wi);
        return L;
    }
    else {
        return vec3(0.);
    }
}

vec3 estimateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material) {
	// Sample light source with multiple importance sampling
    vec3 wi;
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., scatteringPdf = 0., visibility = 0.;

    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;

    bool isBlack = dot(Li, Li) == 0.;

    if (lightPdf > 0. && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction, material) * abs(dot(wi, interaction.normal));
        scatteringPdf = bsdfPdf(wi, wo, interaction, material);

		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           float weight = 1.;//powerHeuristic(1., lightPdf, 1., scatteringPdf);
           Ld += f * Li * weight / lightPdf;
        }
    }

    // Sample BSDF with multiple importance sampling
    /*vec3 f;
    bool sampledSpecular = false;
    // Sample scattered direction for surface interactions
    BxDFType sampledType;
    f = bsdfSample(isect.wo, wi, uScattering, &scatteringPdf, bsdfFlags, &sampledType);
    f *= abs(dot(wi, isect.shading.n);
	bool isBlack = dot(Li, Li) == 0.;
    sampledSpecular = (sampledType & BSDF_SPECULAR) != 0;

    if (!isBlack && scatteringPdf > 0) {
    // Account for light contributions along sampled direction _wi_
    	float weight = 1.;
    	if (!sampledSpecular) {
            lightPdf = light.Pdf_Li(it, wi);
            if (lightPdf == 0) return Ld;
            weight = PowerHeuristic(1, scatteringPdf, 1, lightPdf);
        }

        SurfaceInteraction interaction;
        bool foundSurfaceInteraction = false;
        // Add light contribution from material sampling
        vec3 Li(0.f);
        if (foundSurfaceInteraction) {
            if (lightIsect.primitive->GetAreaLight() == &light)
                Li = lightIsect.Le(-wi);
        } else
            Li = light.Le(ray);
        if (!Li.IsBlack()) Ld += f * Li * Tr * weight / scatteringPdf;
    }*/
    return Ld;
}


uniform sampler2D uRO, uRD;
uniform sampler2D uHit, uNormal;
uniform sampler2D uTCol, uFCol;
uniform sampler2D uBRDF;
uniform int uPassCounter;

layout(location=0) out vec4 outTCol;
layout(location=1) out vec4 outFCol;

void getColor( in Ray ray, inout vec4 tcol, inout vec4 fcol )
{
    MaterialInfo material;

    // vec3 hit = hitScene( ray.origin, ray.dir, material, normal );
    vec3 hit = textureLod( uHit, vTexCoord, 0.0 ).xyz;
    vec3 normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

    if ( hit.y >= 0.0 && hit.z < 10000.0 )
        material = uMaterials[int(hit.y)];

    if ( hit.y >= 0.0 )
    {
        vec3 hitOrigin = ray.origin + ray.dir * hit.x;

        

        if ( material.type == 0 )
        {
            // PBR

            SurfaceInteraction interaction;
            interaction.point = hitOrigin;
            interaction.incomingRayDir = ray.dir;
            interaction.normal = normal;

            vec3 L = tcol.xyz, beta = fcol.xyz;
            vec3 lightEstimation = textureLod( uBRDF, vTexCoord, 0.0 ).xyz;

            // vec3 Ld = beta * estimateDirectLight(vec4(spheres[0].p, spheres[0].r), interaction, material);
            // Ld += beta * estimateDirectLight(vec4(spheres[3].p, spheres[3].r), interaction, material);

            vec3 Ld = beta * lightEstimation;
            L += Ld;

            float pdf = 0.;
            vec3 wo = -interaction.incomingRayDir, wi;
            vec3 f = bsdfSample( wi, wo, pdf, interaction, material);

            if(pdf != 0.)
                beta *=  f * abs(dot(wi, interaction.normal)) / pdf;

            tcol.xyz = L;
            fcol.xyz = beta;
        } else
        if ( material.type == 2 )
        {
            // --- Light
            if ( uPassCounter == 0 ) // produces black light reflections
                tcol = vec4( material.emission, 1.0 );
            fcol.a = STOP_CODE;
        }
    } else
    {
        vec3 backColor = pow( background( ray.origin, ray.dir, normalize( uSunDir ) ).xyz, vec3( 2.2 ) );
        tcol.xyz += fcol.xyz * backColor;
        fcol.a = STOP_CODE;
    }
}

void main()
{
    vec4 inRO = textureLod( uRO, vTexCoord, 0.0 );
    vec4 inRD = textureLod( uRD, vTexCoord, 0.0 );

    vec4 inTCol = vec4( 0, 0, 0, 1 ), inFCol = vec4( 1 );

    if ( uPassCounter > 0 ) {
        inTCol.xyz = textureLod( uTCol, vTexCoord, 0.0 ).xyz;
        inFCol.xyz = textureLod( uFCol, vTexCoord, 0.0 ).xyz;
    }

    Ray ray = Ray( inRO.xyz, inRD.xyz );

    if ( /*inRO.x != STOP_CODE && inRD.x != STOP_CODE &&*/ inFCol.a == STOP_CODE && uPassCounter > 0  ) {}
    else getColor( ray, inTCol, inFCol );

    outTCol = vec4( inTCol );
    outFCol = vec4( inFCol );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 300 es
precision highp float;
in vec4 aPosition;
in vec2 aTexCoord;
out vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 300 es
precision highp float;

in vec2 vTexCoord;

uniform vec3 uOrigin, uLookAt;
uniform float uFov;
uniform vec2 inResolution;

struct MaterialInfo {
    int type;
    int id;

    vec3  baseColor;
    float subsurface;
    float roughness;
    float metallic;
    float specular;
    float specularTint;
    float clearcoat;
    float clearcoatGloss;
    float anisotropic;
    float sheen;
    float sheenTint;

    float bump;
    vec3 emission;
    float ior;
};

float smin( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

vec3 opU( vec3 d1, vec3 d2 )
{
    return (d1.x<d2.x) ? d1 : d2;
}

vec3 opBlend( vec3 d1, vec3 d2, float k )
{
    vec3 rc;
    rc.x=smin( d1.x, d2.x, k );

    if ( d1.x < d2.x )
    {
    	rc.y=d1.y;
        rc.z=d1.z;
    } else
    {
    	rc.y=d2.y;
        rc.z=d2.z;
    }

    return rc;
}

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

vec3 opRep( vec3 p, vec3 c )
{
    return mod(p,c)-0.5*c;
}

vec3 opTwist( vec3 p, float twist )
{
    float c = cos(twist*p.z);
    float s = sin(twist*p.z);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

vec3 opCheapBend( vec3 p, float bend )
{
    float c = cos(bend*p.y);
    float s = sin(bend*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xy,p.z);
    return q;
}

float fold2(float p){
    return abs(p);
}
vec2 fold4(vec2 p){
    return abs(p);
}
vec2 fold6(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.8657, 0.5);
    const vec2 p2 = vec2(0.8657, -0.5);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold8(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    p -= p1 * 2. * min(0., dot(p, p1));
    return p;
}
vec2 fold10(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9510, 0.3090);
    const vec2 p2 = vec2(0.9510, -0.3090);
    const vec2 p3 = vec2(0.5878, -0.8090);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold12(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.8657, -0.5);
    const vec2 p2 = vec2(0.5, -0.8657);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}
vec2 fold14(vec2 p){
    p.y = abs(p.y);
    const vec2 p1 = vec2(0.9749, 0.2225);
    const vec2 p2 = vec2(0.7818, -0.6235);
    const vec2 p3 = vec2(0.4339, -0.9010);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    p -= p3 * 2. * min(0., dot(p, p3));
    return p;
}
vec2 fold16(vec2 p){
    p = abs(p);
    const vec2 p1 = vec2(0.7071, -0.7071);
    const vec2 p2 = vec2(0.3827, -0.9237);
    p -= p1 * 2. * min(0., dot(p, p1));
    p -= p2 * 2. * min(0., dot(p, p2));
    return p;
}

// return inverse R * inverse T
// inverse R = transpose R
mat4 transRotateTaitBryan(vec3 trans, vec3 alpha){
    vec3 c = cos(alpha);
    vec3 s = sin(alpha);
    vec4 v1 = vec4(c.y*c.z, c.x*s.z + c.z*s.x*s.y, s.x*s.z-c.x*c.z*s.y, 0.0);
    vec4 v2 = vec4(-c.y*s.z, c.x*c.z-s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, 0.0);
    vec4 v3 = vec4(s.y, -c.y*s.x, c.x*c.y, 0.0);
    return mat4(
        vec4(v1.x, v2.x, v3.x, 0.0),
        vec4(v1.y, v2.y, v3.y, 0.0),
        vec4(v1.z, v2.z, v3.z, 0.0),
        vec4(-trans, 1.0));
}


uniform mat4 uInvertLocalTransform;
uniform vec3 uLocalScale;
//uniform vec3 uGizmoTrans;
//uniform vec3 uGizmoRotate;



vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    vec3 gResult1;
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp.y = tp.y + -0.7000;
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.900, 0.693, 9.900 ), 0.0 ) ) - 0.010, 0, 0 ) );
   tp=p;
    tp.xz = tp.xz + vec2(-5.8329,-9.1131);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 3.480, 0.990, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-2.9951,-0.3052,-9.3829);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 2 ) );
   tp=p;
    tp = tp + vec3(5.4084,-0.6615,-13.9547);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 7.233, 1.864, 7.908 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(1.8432,-0.9806,-7.3413);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 3.960, 0.198, 1.729 ), 0.0 ) ) - 0.010, 0, 5 ) );
   tp=p;
    tp = tp + vec3(2.2985,-0.5698,-7.7168);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.257, 0.198, 1.729 ), 0.0 ) ) - 0.010, 0, 6 ) );
   tp=p;
    tp = tp + vec3(2.6548,-0.1705,-7.1889);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.653, 0.198, 2.657 ), 0.0 ) ) - 0.010, 0, 7 ) );
   tp=p;
    tp = tp + vec3(-7.0562,-0.6615,-2.0499);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.933, 0.797, 7.908 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(10.2510,-0.6615,-2.0499);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.933, 0.797, 7.908 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(6.9955,-3.3000,-3.7075);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.939, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 11 ) );
   tp=p;
    tp = tp + vec3(7.1909,-3.2000,-3.7807);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 1.188, 1.584, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-3.8335,-3.3000,-3.7075);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 5.138, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 13 ) );
   tp=p;
    tp = tp + vec3(-5.9189,-3.2000,-3.7807);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.376, 2.079, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(1.4252,-3.3000,-8.8139);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 15 ) );
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(1.4252,-3.3000,8.8163);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 2.475, 0.148 ), 0.0 ) ) - 0.010, 0, 16 ) );
   tp=p;
    tp = tp + vec3(5.2596,-5.0000,-0.7289);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.148, 4.950, 3.960 ), 0.0 ) ) - 0.010, 0, 17 ) );
   tp=p;
    tp.xz = tp.zx * vec2(1.0000,-1.0000);
    tp = tp + vec3(-2.2887,-7.8380,-4.8469);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(3.4117,-5.0000,-4.8422);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.980, 4.950, 0.148 ), 0.0 ) ) - 0.010, 0, 19 ) );
   tp=p;
    tp = tp + vec3(4.2562,-7.8380,-4.4534);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4907,-7.8383,-5.0876);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.495, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2562,-3.2000,-4.4534);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4907,-3.2000,-5.0876);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.495, 1.584, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(0.9224,-5.2000,-4.1389);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.838, 5.148, 1.660 ), 0.0 ) ) - 0.010, 0, 24 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-5.2000,0.2454);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 5.148, 0.198 ), 0.0 ) ) - 0.010, 0, 25 ) );
   tp=p;
    tp = tp + vec3(9.3180,-5.2000,3.5272);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.198, 5.148, 3.255 ), 0.0 ) ) - 0.010, 0, 26 ) );
   tp=p;
    tp = tp + vec3(-9.3180,-5.2000,3.5272);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.198, 5.148, 3.255 ), 0.0 ) ) - 0.010, 0, 27 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-5.2000,6.6260);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 5.148, 0.198 ), 0.0 ) ) - 0.010, 0, 28 ) );
   tp=p;
    tp.yz = tp.yz + vec2(-10.4889,3.3101);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 9.405, 0.099, 3.255 ), 0.0 ) ) - 0.010, 0, 29 ) );
   tp=p;
    tp = tp + vec3(7.4331,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-1.0780,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-4.5929,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-8.0199,-7.8380,0.0819);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.188, 0.990 ), 0.0 ) ) - 0.010);
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-4.9243,-5.9269,-4.1547);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 4.950, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 35 ) );
   tp=p;
    tp = tp + vec3(-3.0304,-3.3000,-6.6025);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.402, 2.475, 0.653 ), 0.0 ) ) - 0.010, 0, 36 ) );
   tp=p;
    tp = tp + vec3(-8.5374,-3.2000,-6.6025);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.402, 2.475, 0.653 ), 0.0 ) ) - 0.010, 0, 37 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(3.4808,-9.7717,-1.1778);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.383, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 39 ) );
   tp=p;
    tp = tp + vec3(7.3254,-5.9269,0.0587);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.123, 0.297, 4.415 ), 0.0 ) ) - 0.010, 0, 40 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 42 ) );
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2554,-3.1945,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 44 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 46 ) );
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(4.2554,-7.8383,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 48 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.5424);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 1.485, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 50 ) );
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.5424);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.990, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(7.1997,-3.1945,-3.4095);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 52 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-4.6197,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 54 ) );
   tp=p;
    tp = tp + vec3(-4.6197,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-4.6197,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 56 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-1.1052,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 58 ) );
   tp=p;
    tp = tp + vec3(-1.1052,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-1.1052,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 60 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-8.0062,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 62 ) );
   tp=p;
    tp = tp + vec3(-8.0062,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-8.0062,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 64 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.594, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 66 ) );
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.297, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4845,-3.1945,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.297, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 68 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.6764);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.594, 1.584, 0.198 ), 0.0 ) ) - 0.010, 0, 70 ) );
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.6764);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.297, 1.386, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(2.4845,-7.8538,-4.5435);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.297, 1.485, 0.148 ), 0.0 ) ) - 0.010, 0, 72 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(7.4230,-7.8622,0.3196);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.990, 1.188, 0.198 ), 0.0 ) ) - 0.010, 0, 74 ) );
   tp=p;
    tp = tp + vec3(7.4230,-7.8622,0.3196);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 0.792, 0.990, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(7.4230,-7.8291,0.4525);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 0.792, 0.990, 0.148 ), 0.0 ) ) - 0.010, 0, 76 ) );
    res=opU( res, gResult1 );
    gResult1 = vec3( 1000000, -2, -1 );
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.5246);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.475, 1.980, 0.198 ), 0.0 ) ) - 0.010, 0, 78 ) );
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.5246);
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 2.178, 1.782, 0.495 ), 0.0 ) ) - 0.010);
   tp=p;
    tp = tp + vec3(-5.9294,-3.3875,-3.3917);
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 2.178, 1.980, 0.148 ), 0.0 ) ) - 0.010, 0, 80 ) );
    res=opU( res, gResult1 );
   tp=p;
    tp = tp + vec3(-3.9968,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 82 ) );
   tp=p;
    tp = tp + vec3(-5.0704,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 83 ) );
   tp=p;
    tp = tp + vec3(-6.1014,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 84 ) );
   tp=p;
    tp = tp + vec3(-7.1090,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 85 ) );
   tp=p;
    tp = tp + vec3(-8.3756,-0.3052,-9.3829);
    res=opU( res, vec3( length( max( abs( tp) - vec3( 0.116, 0.567, 0.339 ), 0.0 ) ) - 0.010, 0, 86 ) );
   tp=p;
    res=opU( res, vec3( tp.y + 0.000, 0, 87 ) );
    return res;
}


uniform sampler2D uRO, uRD, uHit, uNormal;

uniform int uOffset, uStep;
uniform float uTMin, uTMax;
uniform float uStepSize;

layout(location=0) out vec4 outHit;
layout(location=1) out vec4 outNormal;

vec3 calcNormalA(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x
    );
    return normalize(nor);
}

const int NORMAL_STEPS = 6;

vec3 calcNormalB(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).x * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

/*
vec3 calc_normal(vec3 p) {

    vec3 epsilon = vec3(0.001, 0., 0.);

    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,
                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,
                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);

    return normalize(n);
}*/

vec3 castRay( in vec3 ro, in vec3 rd, in float tmax, in vec3 res )
{
    float t=res.x, m=res.y, id=res.z;

    for( int i = uOffset; i < (uOffset + uStep); i++ )
    {
        float precis = 0.0001;// * t;

        vec3 res = map( ro+rd*t );
        // <! ABS !>
        // if( t<precis || t>tmax ) break;
        t += res.x * uStepSize;
        if ( res.x <= precis ) {
            m = res.y;
            id = res.z;
            break;
        }
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}

void main()
{
    vec3 inRO = textureLod( uRO, vTexCoord, 0.0 ).xyz;
    vec3 inRD = textureLod( uRD, vTexCoord, 0.0 ).xyz;

    vec3 res, normal = vec3( 0 );

    if ( uOffset == 0 ) res = vec3( uTMin, -1, -1 );
    else {
        res = textureLod( uHit, vTexCoord, 0.0 ).xyz;
        normal = textureLod( uNormal, vTexCoord, 0.0 ).xyz;

        if ( res.y >= 0.0 ) {
            outHit = vec4( res, 1.0 );
            outNormal = vec4( normal, 1.0 );
            return;
        }
    }

    vec3 hit = castRay( inRO, inRD, uTMax, res );
    if ( hit.y >= 0.0 ) {
        normal = calcNormalB( inRO + inRD * hit.x );
    }

    outHit = vec4( hit, 1.0 );
    outNormal = vec4( normal, 1.0 );
}
__ENDPROGRAM__
__BEGINPROGRAM__
__VERTEXSHADER__
#version 100
precision mediump float;
attribute vec4 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
void main() {
   vTexCoord = vec2(aTexCoord.x, aTexCoord.y);
   gl_Position = aPosition;
}

__FRAGMENTSHADER__
#version 100
precision mediump float;

varying vec2 vTexCoord;

uniform sampler2D uColorMap, uBlendMap;
uniform vec2 uSize;

uniform int uBlendMode;
uniform float uBlendAlpha;

vec4 getBlendedColor( in vec2 texCoord )
{
    vec4 color = texture2D( uColorMap, texCoord );

    if ( uBlendMode == 0 ) return color;
    else
    if ( uBlendMode == 1 ) {

        vec4 blendColor = texture2D( uBlendMap, texCoord );

        blendColor *= uBlendAlpha;

        vec4 mixColor;

        mixColor.a = 1.0 - (1.0 - blendColor.a) * (1.0 - color.a); // alpha
        mixColor.x = blendColor.x + color.x * (1.0 - blendColor.a );
        mixColor.y = blendColor.y + color.y * (1.0 - blendColor.a );
        mixColor.z = blendColor.z + color.z * (1.0 - blendColor.a );

        return mixColor;
    } else
    if ( uBlendMode == 2 ) {

        vec4 blendColor = texture2D( uBlendMap, texCoord );

        blendColor.a*=uBlendAlpha;

        vec4 mixColor;

        if ( color.a > 0.0 ) {
            color.x /= color.a;
            color.y /= color.a;
            color.z /= color.a;
        }

        mixColor.a = max( 0.0, color.a - blendColor.a);
        mixColor.x = color.x;
        mixColor.y = color.y;
        mixColor.z = color.z;

        mixColor.x *= mixColor.a;
        mixColor.y *= mixColor.a;
        mixColor.z *= mixColor.a;

        return mixColor;
    } else
    if ( uBlendMode == 3 ) {

        color.x*=color.a;
        color.y*=color.a;
        color.z*=color.a;

        return color;
    } else
    if ( uBlendMode == 4 ) {

        if ( color.a > 0.0 ) {
            color.x/=color.a;
            color.y/=color.a;
            color.z/=color.a;
        }

        return color;
    } else
    return color;
}

void main()
{
    vec4 color = getBlendedColor( vTexCoord );

    gl_FragColor = color;
}
__ENDPROGRAM__
